.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ODBC 3"
.TH ODBC 3 "2016-10-06" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::ODBC \- ODBC Driver for DBI
.SH "VERSION"
.IX Header "VERSION"
This documentation refers to \s-1DBD::ODBC\s0 version 1.56.
.SH "WARNING"
.IX Header "WARNING"
This version of \s-1DBD::ODBC\s0 contains a significant fix to unicode when
inserting into \s-1CHAR/VARCHAR\s0 columns and it is a change in behaviour
from 1.45. The change \fBonly\fR applies to unicode builds of \s-1DBD::ODBC\s0
(the default on Windows but you can build it for unicode on unix too)
and char/varchar columns and not nchar/nvarchar columns.
.PP
Prior to this release of \s-1DBD::ODBC\s0 when you are using the unicode
build of \s-1DBD::ODBC\s0 and inserted data into a \s-1CHAR/VARCHAR\s0 columns using
parameters \s-1DBD::ODBC\s0 did this:
.PP
1 if you set odbc_describe_parameters to 0, (thus preventing \s-1DBD::ODBC\s0
  from calling SQLDescribeParam) parameters for \s-1CHAR/VARCHAR\s0 columns
  were bound as \s-1SQL_WVARCHAR\s0 or \s-1SQL_WLONGVARCHAR\s0 (depending on the
  length of the parameter).
.PP
2 if you set odbc_force_bind_type then all parameters are bound as you
  specified.
.PP
3 if you override the parameter type in the bind_param method, the
  type you specified would be used.
.PP
4 if the driver does not support SQLDescribeParam or SQLDescribeParam
  was called and failed then the bind type defaulted as in 1.
.PP
5 if none of the above (and I'd guess that is the normal case for most
  people) then \s-1DBD::ODBC\s0 calls SQLDescribeParam to find the parameter
  type. This usually returns \s-1SQL_CHAR\s0 or \s-1SQL_VARCHAR\s0 for \s-1CHAR/VARCHAR\s0
  columns unsurprisingly. The parameter was then bound as \s-1SQL_VARCHAR.\s0
.PP
Items 1 to 4 still apply. 5 now has a different behaviour. In this
release, \s-1DBD::ODBC\s0 now looks at your bound data first before using the
type returned by SQLDescribeParam. If you data looks like unicode
(i.e., \fBSvUTF8()\fR is true) it now binds the parameter as \s-1SQL_WVARCHAR.\s0
.PP
What might this might mean to you?
.PP
If you had Perl scalars that were bound to \s-1CHAR/VARCHAR\s0 columns in an
insert/update/delete and those scalars contained unicode, \s-1DBD::ODBC\s0
would actually pass the individual octets in your scalar not
characters.  For instance, if you had the Perl scalar \*(L"\ex{20ac}\*(R" (the
Euro unicode character) and you bound it to a \s-1CHAR/VARCHAR, DBD::ODBC\s0
would pass 0xe2, 0x82, 0xc2 as separate characters because those bytes
were Perl's \s-1UTF\-8\s0 encoding of a euro. These would probably be
interpreted by your database engine as 3 characters in its current
codepage. If you queried your database to find the length of the data
inserted you'd probably get back 3, not 1.
.PP
However, when \s-1DBD::ODBC\s0 read that column back in a select
statement, it would bind the column as \s-1SQL_WCHAR\s0 and you'd get back 3
characters with the utf8 flag on (what those characters were depends
on how your database or driver translates code page characters to wide
characters).
.PP
What should happen now is that if your bound parameters are unicode,
\&\s-1DBD::ODBC\s0 will bind them as wide characters (unicode) and your driver
or database will attempt to convert them into the code page it is
using. This means so long as your database can store the data you are
inserting, when you read it back you should get what you inserted.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI;
\&
\&  $dbh = DBI\->connect(\*(Aqdbi:ODBC:DSN=mydsn\*(Aq, \*(Aquser\*(Aq, \*(Aqpassword\*(Aq);
.Ve
.PP
See \s-1DBI\s0 for more information.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Change log and FAQs"
.IX Subsection "Change log and FAQs"
Please note that the change log has been moved to
DBD::ODBC::Changes. To access this documentation, use
\&\f(CW\*(C`perldoc DBD::ODBC::Changes\*(C'\fR.
.PP
The FAQs have also moved to \s-1DBD::ODBC::FAQ\s0.pm. To access the FAQs use
\&\f(CW\*(C`perldoc DBD::ODBC::FAQ\*(C'\fR.
.SS "Important note about the tests"
.IX Subsection "Important note about the tests"
\&\s-1DBD::ODBC\s0 is unlike most other DBDs in that it connects to literally
dozens of possible \s-1ODBC\s0 Drivers. It is practically impossible for me
to test every one and so some tests may fail with some \s-1ODBC\s0 Drivers.
This does not mean \s-1DBD::ODBC\s0 will not work with your \s-1ODBC\s0 Driver but
it is worth reporting any test failures on rt.cpan.org or to the
dbi-users mailing list.
.SS "\s-1DBI\s0 attribute handling"
.IX Subsection "DBI attribute handling"
If a \s-1DBI\s0 defined attribute is not mentioned here it behaves as per the
\&\s-1DBI\s0 specification.
.PP
\fIReadOnly (boolean)\fR
.IX Subsection "ReadOnly (boolean)"
.PP
\&\s-1DBI\s0 documents the \f(CW\*(C`ReadOnly\*(C'\fR attribute as being settable and
retrievable on connection and statement handles. In \s-1ODBC\s0 setting
ReadOnly to true causes the connection attribute \f(CW\*(C`SQL_ATTR_ACCESS_MODE\*(C'\fR
to be set to \f(CW\*(C`SQL_MODE_READ_ONLY\*(C'\fR and setting it to false will set the
access mode to \f(CW\*(C`SQL_MODE_READ_WRITE\*(C'\fR (which is the default in \s-1ODBC\s0).
.PP
\&\fBNote:\fR There is no equivalent of setting ReadOnly on a statement
handle in \s-1ODBC.\s0
.PP
\&\fBNote:\fR See \s-1ODBC\s0 documentation on \f(CW\*(C`SQL_ATTR_ACCESS_MODE\*(C'\fR as setting it
to \f(CW\*(C`SQL_MODE_READ_ONLY\*(C'\fR does \fBnot\fR prevent your script from running
updates or deletes; it is simply a hint to the driver/database that
you won't being doing updates.
.PP
\&\fBNote:\fR Since \s-1DBD::ODCB 1.44_3,\s0 if the driver does not support
setting \f(CW\*(C`SQL_ATTR_ACCESS_MODE\*(C'\fR and returns \s-1SQL_SUCCESS_WITH_INFO\s0 and
\&\*(L"option value changed\*(R" a warning is issued (which you'll only see if
you have \s-1DBI\s0 > 1.628).  In addition, any subsequent attempts to fetch
the ReadOnly attribute will return the value last set.
.PP
This attribute requires \s-1DBI\s0 version 1.55 or better.
.SS "Private attributes common to connection and statement handles"
.IX Subsection "Private attributes common to connection and statement handles"
\fIodbc_ignore_named_placeholders\fR
.IX Subsection "odbc_ignore_named_placeholders"
.PP
Use this if you have special needs (such as Oracle triggers, etc)
where :new or :name mean something special and are not just place
holder names. You \fBmust\fR then use ? for binding parameters.  Example:
.PP
.Vb 2
\& $dbh\->{odbc_ignore_named_placeholders} = 1;
\& $dbh\->do("create trigger foo as if :new.x <> :old.x then ... etc");
.Ve
.PP
Without this, \s-1DBD::ODBC\s0 will think :new and :old are placeholders for
binding and get confused.
.PP
\fIodbc_default_bind_type\fR
.IX Subsection "odbc_default_bind_type"
.PP
This value defaults to 0.
.PP
Older versions of \s-1DBD::ODBC\s0 assumed that the parameter binding type
was 12 (\f(CW\*(C`SQL_VARCHAR\*(C'\fR).  Newer versions always attempt to call
\&\f(CW\*(C`SQLDescribeParam\*(C'\fR to find the parameter types but if
\&\f(CW\*(C`SQLDescribeParam\*(C'\fR is unavailable \s-1DBD::ODBC\s0 falls back to a default
bind type. The internal default bind type is \f(CW\*(C`SQL_VARCHAR\*(C'\fR (for
non-unicode build) and \f(CW\*(C`SQL_WVARCHAR\*(C'\fR or \f(CW\*(C`SQL_VARCHAR\*(C'\fR (for a
unicode build depending on whether the parameter is unicode or
not). If you set \f(CW\*(C`odbc_default_bind_type\*(C'\fR to a value other than 0 you
override the internal default.
.PP
\&\fBN.B\fR If you call the \f(CW\*(C`bind_param\*(C'\fR method with a \s-1SQL\s0 type this
overrides everything else above.
.PP
\fIodbc_force_bind_type\fR
.IX Subsection "odbc_force_bind_type"
.PP
This value defaults to 0.
.PP
If set to anything other than 0 this will force bound parameters to be
bound as this type and \f(CW\*(C`SQLDescribeParam\*(C'\fR will not be used; in other
words it implies \*(L"odbc_describe_parameters\*(R" is set to false too.
.PP
Older versions of \s-1DBD::ODBC\s0 assumed the parameter binding type was 12
(\f(CW\*(C`SQL_VARCHAR\*(C'\fR) and newer versions always attempt to call
\&\f(CW\*(C`SQLDescribeParam\*(C'\fR to find the parameter types. If your driver
supports \f(CW\*(C`SQLDescribeParam\*(C'\fR and it succeeds it may still fail to
describe the parameters accurately (\s-1MS SQL\s0 Server sometimes does this
with some \s-1SQL\s0 like \fIselect myfunc(?)  where 1 = 1\fR). Setting
\&\f(CW\*(C`odbc_force_bind_type\*(C'\fR to \f(CW\*(C`SQL_VARCHAR\*(C'\fR will force \s-1DBD::ODBC\s0 to bind
all the parameters as \f(CW\*(C`SQL_VARCHAR\*(C'\fR and ignore SQLDescribeParam.
.PP
Bear in mind that if you are inserting unicode data you probably want
to use \f(CW\*(C`SQL_WVARCHAR\*(C'\fR/\f(CW\*(C`SQL_WCHAR\*(C'\fR/\f(CW\*(C`SQL_WLONGVARCHAR\*(C'\fR and not
\&\f(CW\*(C`SQL_VARCHAR\*(C'\fR.
.PP
As this attribute was created to work around buggy \s-1ODBC\s0 Drivers which
support SQLDescribeParam but describe the parameters incorrectly you
are probably better specifying the bind type on the \f(CW\*(C`bind_param\*(C'\fR call
on a per statement level rather than blindly setting
\&\f(CW\*(C`odbc_force_bind_type\*(C'\fR across a whole connection.
.PP
\&\fBN.B\fR If you call the \f(CW\*(C`bind_param\*(C'\fR method with a \s-1SQL\s0 type this
overrides everything else above.
.PP
\fIodbc_force_rebind\fR
.IX Subsection "odbc_force_rebind"
.PP
This is to handle special cases, especially when using multiple result sets.
Set this before execute to \*(L"force\*(R" \s-1DBD::ODBC\s0 to re-obtain the result set's
number of columns and column types for each execute.  Especially useful for
calling stored procedures which may return different result sets each
execute.  The only performance penalty is during \fBexecute()\fR, but I didn't
want to incur that penalty for all circumstances.  It is probably fairly
rare that this occurs.  This attribute will be automatically set when
multiple result sets are triggered.  Most people shouldn't have to worry
about this.
.PP
\fIodbc_async_exec\fR
.IX Subsection "odbc_async_exec"
.PP
Allow asynchronous execution of queries.  This causes a spin-loop
(with a small \*(L"sleep\*(R") until the \s-1ODBC API\s0 being called is complete
(i.e., while the \s-1ODBC API\s0 returns \f(CW\*(C`SQL_STILL_EXECUTING\*(C'\fR).  This is
useful, however, if you want the error handling and asynchronous
messages (see the \*(L"odbc_err_handler\*(R" and \fIt/20SQLServer.t\fR for an
example of this).
.PP
\fIodbc_query_timeout\fR
.IX Subsection "odbc_query_timeout"
.PP
This allows you to change the \s-1ODBC\s0 query timeout (the \s-1ODBC\s0 statement
attribute \f(CW\*(C`SQL_ATTR_QUERY_TIMEOUT\*(C'\fR). \s-1ODBC\s0 defines the query time out as
the number of seconds to wait for a \s-1SQL\s0 statement to execute before
returning to the application. A value of 0 (the default) means there
is no time out. Do not confuse this with the \s-1ODBC\s0 attributes
\&\f(CW\*(C`SQL_ATTR_LOGIN_TIMEOUT\*(C'\fR and \f(CW\*(C`SQL_ATTR_CONNECTION_TIMEOUT\*(C'\fR. Add
.PP
.Vb 1
\&  { odbc_query_timeout => 30 }
.Ve
.PP
to your connect, set on the \f(CW\*(C`dbh\*(C'\fR before creating a statement or
explicitly set it on your statement handle. The odbc_query_timeout on
a statement is inherited from the parent connection.
.PP
Note that internally \s-1DBD::ODBC\s0 only sets the query timeout if you set it
explicitly and the default of 0 (no time out) is implemented by the
\&\s-1ODBC\s0 driver and not \s-1DBD::ODBC.\s0
.PP
Note that some \s-1ODBC\s0 drivers implement a maximum query timeout value
and will limit timeouts set above their maximum. You may see a
warning if your time out is capped by the driver but there is
currently no way to retrieve the capped value back from the driver.
.PP
Note that some drivers may not support this attribute.
.PP
See \fIt/20SqlServer.t\fR for an example.
.PP
\fIodbc_putdata_start\fR
.IX Subsection "odbc_putdata_start"
.PP
\&\f(CW\*(C`odbc_putdata_start\*(C'\fR defines the size at which \s-1DBD::ODBC\s0 uses
\&\f(CW\*(C`SQLPutData\*(C'\fR and \f(CW\*(C`SQLParamData\*(C'\fR to send larger objects to the
database instead of simply binding them as normal with
\&\f(CW\*(C`SQLBindParameter\*(C'\fR. It is mostly a placeholder for future changes
allowing chunks of data to be sent to the database and there is little
reason for anyone to change it currently.
.PP
The default for odbc_putdata_start is 32768 because this value was
hard-coded in \s-1DBD::ODBC\s0 until 1.16_1.
.PP
\fIodbc_column_display_size\fR
.IX Subsection "odbc_column_display_size"
.PP
If you \s-1ODBC\s0 driver does not support the \s-1SQL_COLUMN_DISPLAY_SIZE\s0 and
\&\s-1SQL_COLUMN_LENGTH\s0 attributes to SQLColAtrributes then \s-1DBD::ODBC\s0 does
not know how big the column might be. odbc_column_display_size sets
the default value for the column size when retrieving column data
where the size cannot be determined.
.PP
The default for odbc_column_display_size is 2001 because this value was
hard-coded in \s-1DBD::ODBC\s0 until 1.17_3.
.PP
\fIodbc_utf8_on\fR
.IX Subsection "odbc_utf8_on"
.PP
Set this flag to treat all strings returned from the \s-1ODBC\s0 driver
(except columns described as \s-1SQL_BINARY\s0 or \s-1SQL_TIMESTAMP\s0 and its
variations) as \s-1UTF\-8\s0 encoded.  Some \s-1ODBC\s0 drivers (like Aster and maybe
PostgreSQL) return \s-1UTF\-8\s0 encoded data but do not support the SQLxxxW
unicode \s-1API.\s0 Enabling this flag will cause \s-1DBD::ODBC\s0 to treat driver
returned data as \s-1UTF\-8\s0 encoded and it will be marked as such in Perl.
.PP
Do not confuse this with \s-1DBD::ODBC\s0's unicode support. The
\&\f(CW\*(C`odbc_utf8_on\*(C'\fR attribute only applies to non-unicode enabled builds
of \s-1DBD::ODBC.\s0
.PP
\fIodbc_describe_parameters\fR
.IX Subsection "odbc_describe_parameters"
.PP
Defaults to on. When set this allows \s-1DBD::ODBC\s0 to call SQLDescribeParam
(if the driver supports it) to retrieve information about any
parameters.
.PP
When off/false \s-1DBD::ODBC\s0 will not call SQLDescribeParam and defaults
to binding parameters as \s-1SQL_CHAR/SQL_WCHAR\s0 depending on the build
type and whether your data is unicode or not.
.PP
You do not have to disable odbc_describe_parameters just because your
driver does not support SQLDescribeParam as \s-1DBD::ODBC\s0 will work this
out at the start via SQLGetFunctions.
.PP
\&\fBNote\fR: disabling odbc_describe_parameters when your driver does support
SQLDescribeParam may prevent \s-1DBD::ODBC\s0 binding parameters for some
column types properly.
.PP
You can also set this attribute in the attributes passed to the
prepare method.
.PP
This attribute was added so someone moving from freeTDS (a driver
which does not support SQLDescribeParam) to a driver which does
support SQLDescribeParam could do so without changing any Perl. The
situation was very specific since dates were being bound as dates when
SQLDescribeParam was called and chars without and the data format was
not a supported date format.
.SS "Private methods common to connection and statement handles"
.IX Subsection "Private methods common to connection and statement handles"
\fIodbc_getdiagrec\fR
.IX Subsection "odbc_getdiagrec"
.PP
.Vb 1
\&  @diags = $handle\->odbc_getdiagrec($record_number);
.Ve
.PP
Introduced in 1.34_3.
.PP
This is just a wrapper around the \s-1ODBC API\s0 SQLGetDiagRec. When a
method on a connection or statement handle fails if there are any \s-1ODBC\s0
diagnostics you can use this method to retrieve them. Records start at
1 and there may be more than 1. It returns an array containing the
state, native and error message text or an empty array if the requested
diagnostic record does not exist. To get all diagnostics available
keep incrementing \f(CW$record_number\fR until odbc_getdiagrec returns an
empty array.
.PP
All of the state, native and message text are already passed to \s-1DBI\s0
via its set_err method so this method does not really tell you
anything you cannot already get from \s-1DBI\s0 except when there is more
than one diagnostic.
.PP
You may find this useful in an error handler as you can get the \s-1ODBC\s0
diagnostics as they are and not how \s-1DBD::ODBC\s0 was forced to fit them
into the \s-1DBI\s0's system.
.PP
\&\s-1NOTE:\s0 calling this method does not clear \s-1DBI\s0's error values as usually
happens.
.PP
\fIodbc_getdiagfield\fR
.IX Subsection "odbc_getdiagfield"
.PP
.Vb 1
\&  $diag = $handle\->odbc_getdiagfield($record, $identifier);
.Ve
.PP
This is just a wrapper around the \s-1ODBC API\s0 SQLGetDiagField. When a
method on a connection or statement handle fails if there are any
\&\s-1ODBC\s0 diagnostics you can use this method to retrieve the individual
diagnostic fields. As with \*(L"odbc_getdiagrec\*(R" records start at 1. The
identifier is one of:
.PP
.Vb 10
\&  SQL_DIAG_CURSOR_ROW_COUNT
\&  SQL_DIAG_DYNAMIC_FUNCTION
\&  SQL_DIAG_DYNAMIC_FUNCTION_CODE
\&  SQL_DIAG_NUMBER
\&  SQL_DIAG_RETURNCODE
\&  SQL_DIAG_ROW_COUNT
\&  SQL_DIAG_CLASS_ORIGIN
\&  SQL_DIAG_COLUMN_NUMBER
\&  SQL_DIAG_CONNECTION_NAME
\&  SQL_DIAG_MESSAGE_TEXT
\&  SQL_DIAG_NATIVE
\&  SQL_DIAG_ROW_NUMBER
\&  SQL_DIAG_SERVER_NAME
\&  SQL_DIAG_SQLSTATE
\&  SQL_DIAG_SUBCLASS_ORIGIN
.Ve
.PP
\&\s-1DBD::ODBC\s0 exports these constants as 'diags' e.g.,
.PP
.Vb 1
\&  use DBD::ODBC qw(:diags);
.Ve
.PP
Of particular interest is \s-1SQL_DIAG_COLUMN_NUMBER\s0 as it will tell you
which bound column or parameter is in error (assuming your driver
supports it). See params_in_error in the examples dir.
.PP
\&\s-1NOTE:\s0 calling this method does not clear \s-1DBI\s0's error values as usually
happens.
.SS "Private connection attributes"
.IX Subsection "Private connection attributes"
\fIodbc_err_handler\fR
.IX Subsection "odbc_err_handler"
.PP
\&\fB\s-1NOTE:\s0\fR You might want to look at \s-1DBI\s0's error handler before using
the one in \s-1DBD::ODBC\s0 however, there are subtle
differences. \s-1DBD::ODBC\s0's odbc_err_handler is called for error \fBand\fR
informational diagnostics i.e., it is called when an \s-1ODBC\s0 call fails
the \s-1SQL_SUCCEEDED\s0 macro which means the \s-1ODBC\s0 call returned \s-1SQL_ERROR\s0
(\-1) or \s-1SQL_SUCCESS_WITH_INFO\s0 (1).
.PP
Allow error and informational diagnostics to be handled by the
application.  A call-back function supplied by the application to
handle or ignore messages.
.PP
The callback function receives four parameters: state (string),
error (string), native error code (number) and the status returned
from the last \s-1ODBC API.\s0 The fourth argument was added in 1.30_7.
.PP
If the error handler returns 0, the error is ignored, otherwise the
error is passed through the normal \s-1DBI\s0 error handling. Note, if the
status is \s-1SQL_SUCCESS_WITH_INFO\s0 this will \fBnot\fR reach the \s-1DBI\s0 error
handler as it is not an error.
.PP
This can also be used for procedures under \s-1MS SQL\s0 Server (Sybase too,
probably) to obtain messages from system procedures such as \s-1DBCC.\s0
Check \fIt/20SQLServer.t\fR and \fIt/10handler.t\fR.
.PP
.Vb 11
\&  $dbh\->{RaiseError} = 1;
\&  sub err_handler {
\&     ($state, $msg, $native, $rc, $status) = @_;
\&     if ($state = \*(Aq12345\*(Aq)
\&         return 0; # ignore this error
\&     else
\&         return 1; # propagate error
\&  }
\&  $dbh\->{odbc_err_handler} = \e&err_handler;
\&  # do something to cause an error
\&  $dbh\->{odbc_err_handler} = undef; # cancel the handler
.Ve
.PP
\fIodbc_SQL_ROWSET_SIZE\fR
.IX Subsection "odbc_SQL_ROWSET_SIZE"
.PP
Setting odbc_SQL_ROWSET_SIZE results in a call to SQLSetConnectAttr
to set the \s-1ODBC SQL_ROWSET_SIZE\s0 (9) attribute to whatever value you
set odbc_SQL_ROWSET_SIZE to.
.PP
The \s-1ODBC\s0 default for \s-1SQL_ROWSET_SIZE\s0 is 1.
.PP
Usually \s-1MS SQL\s0 Server does not support multiple active statements
(\s-1MAS\s0) i.e., you cannot have 2 or more outstanding selects.  You can
set odbc_SQL_ROWSET_SIZE to 2 to persuade \s-1MS SQL\s0 Server to support
multiple active statements.
.PP
Setting \s-1SQL_ROWSET_SIZE\s0 usually only affects calls to SQLExtendedFetch
but does allow \s-1MAS\s0 and as \s-1DBD::ODBC\s0 does not use SQLExtendedFetch there
should be no ill effects to \s-1DBD::ODBC.\s0
.PP
Be careful with this attribute as once set to anything larger than 1
(the default) you must retrieve all result-sets before the statement
handle goes out of scope or you can upset the \s-1TDS\s0 protocol and this
can result in a hang. With \s-1DBI\s0 this is unlikely as \s-1DBI\s0 warns when a
statement goes out of scope with outstanding results.
.PP
\&\s-1NOTE:\s0 if you get an error saying \*(L"[Microsoft][\s-1ODBC SQL\s0 Server
Driver]Invalid attribute/option identifier (\s-1SQL\-HY092\s0)\*(R" when you set
odbc_SQL_ROWSET_SIZE in the connect method you need to either a)
upgrade to \s-1DBI 1.616\s0 or above b) set odbc_SQL_ROWSET_SIZE after
connect.
.PP
In versions of \s-1SQL\s0 Server 2005 and later see \*(L"Multiple Active
Statements (\s-1MAS\s0)\*(R" in the \s-1DBD::ODBC::FAQ\s0 instead of using this
attribute.
.PP
Thanks to Andrew Brown for the original patch.
.PP
\&\s-1DBD\s0 developer note: Here lies a bag of worms. Firstly, \s-1SQL_ROWSET_SIZE\s0
is an \s-1ODBC 2\s0 attribute and is usually a statement attribute not a
connection attribute. However, in \s-1ODBC 2.0\s0 you could set statement
attributes on a connection handle and it acted as a default for all
subsequent statement handles created under that connection handle. If
you are using \s-1ODBC 3\s0 the driver manager continues to map this call but
the \s-1ODBC\s0 Driver needs to act on it (the \s-1MS SQL\s0 Server driver still
appears to but some other \s-1ODBC\s0 drivers for \s-1MS SQL\s0 Server do not).
Secondly, somewhere a long the line \s-1MS\s0 decided it was no longer valid
to retrieve the \s-1SQL_ROWSET_SIZE\s0 attribute from a connection handle in
an \s-1ODBC 3\s0 application (which \s-1DBD::ODBC\s0 now is). In itself, this would
not be a problem except for a minor bug in \s-1DBI\s0 which until release
1.616 mistakenly issued a \s-1FETCH\s0 on any attribute mentioned in the
connect method call. As a result, it you use a \s-1DBI\s0 prior to 1.616 and
attempt to set odbc_SQL_ROWSET_SIZE in the connect method call, \s-1DBI\s0
issues a \s-1FETCH\s0 on odbc_SQL_ROWSET_SIZE and the driver manager throws
it out as an invalid attribute thus resulting in an error. The only
way around this (other than upgrading \s-1DBI\s0) is to set
odbc_SQL_ROWSET_SIZE \s-1AFTER\s0 the call to connect. Thirdly, \s-1MS\s0 withdrew
the \s-1SQLROWSETSIZE\s0 macro from the sql header files in \s-1MDAC 2.7\s0 for 64
bit platforms i.e., \s-1SQLROWSETSIZE\s0 is not defined on 64 bit platforms
from \s-1MDAC 2.7\s0 as it is in a \*(L"#ifdef win32\*(R" (see
http://msdn.microsoft.com/en\-us/library/ms716287%28v=vs.85%29.aspx).
Setting \s-1SQL_ROWSET_SIZE\s0 still seems to take effect on 64 bit platforms
but you can no longer retrieve its value from a connection handle
(hence the issue above with \s-1DBI\s0 redundant \s-1FETCH\s0).
.PP
\fIodbc_exec_direct\fR
.IX Subsection "odbc_exec_direct"
.PP
Force \s-1DBD::ODBC\s0 to use \f(CW\*(C`SQLExecDirect\*(C'\fR instead of
\&\f(CW\*(C`SQLPrepare\*(C'\fR/\f(CW\*(C`SQLExecute\*(C'\fR.
.PP
There are drivers that only support \f(CW\*(C`SQLExecDirect\*(C'\fR and the \s-1DBD::ODBC\s0
\&\fBdo()\fR override does not allow returning result sets.  Therefore, the
way to do this now is to set the attribute odbc_exec_direct.
.PP
\&\s-1NOTE:\s0 You may also want to use this option if you are creating
temporary objects (e.g., tables) in \s-1MS SQL\s0 Server and for some
reason cannot use the \f(CW\*(C`do\*(C'\fR method. see
<http://technet.microsoft.com/en\-US/library/ms131667.aspx> which says
\&\fIPrepared statements cannot be used to create temporary objects on
\&\s-1SQL\s0 Server 2000 or later...\fR. Without odbc_exec_direct, the temporary
object will disappear before you can use it.
.PP
There are currently two ways to get this:
.PP
.Vb 1
\&    $dbh\->prepare($sql, { odbc_exec_direct => 1});
.Ve
.PP
and
.PP
.Vb 1
\&    $dbh\->{odbc_exec_direct} = 1;
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR Even if you build \s-1DBD::ODBC\s0 with unicode support you can
still not pass unicode strings to the prepare method if you also set
odbc_exec_direct. This is a restriction in this attribute which is
unavoidable.
.PP
\fIodbc_SQL_DRIVER_ODBC_VER\fR
.IX Subsection "odbc_SQL_DRIVER_ODBC_VER"
.PP
This, while available via \fBget_info()\fR is captured here.  I may get rid
of this as I only used it for debugging purposes.
.PP
\fIodbc_cursortype\fR
.IX Subsection "odbc_cursortype"
.PP
This allows multiple concurrent statements on SQL*Server.  In your
connect, add
.PP
.Vb 1
\&  { odbc_cursortype => 2 }.
.Ve
.PP
If you are using \s-1DBI\s0 > 1.41, you should also be able to use
.PP
.Vb 1
\& { odbc_cursortype => DBI::SQL_CURSOR_DYNAMIC }
.Ve
.PP
instead.  For example:
.PP
.Vb 9
\&    my $dbh = DBI\->connect("dbi:ODBC:$DSN", $user, $pass,
\&                  { RaiseError => 1, odbc_cursortype => 2});
\&    my $sth = $dbh\->prepare("one statement");
\&    my $sth2 = $dbh\->prepare("two statement");
\&    $sth\->execute;
\&    my @row;
\&    while (@row = $sth\->fetchrow_array) {
\&       $sth2\->execute($row[0]);
\&    }
.Ve
.PP
See \fIt/20SqlServer.t\fR for an example.
.PP
In versions of \s-1SQL\s0 Server 2005 and later see \*(L"Multiple Active Statements (\s-1MAS\s0)\*(R" in the \s-1DBD::ODBC::FAQ\s0 instead of using this attribute.
.PP
\fIodbc_has_unicode\fR
.IX Subsection "odbc_has_unicode"
.PP
A read-only attribute signifying whether \s-1DBD::ODBC\s0 was built with the
C macro \s-1WITH_UNICODE\s0 or not. A value of 1 indicates \s-1DBD::ODBC\s0 was built
with \s-1WITH_UNICODE\s0 else the value returned is 0.
.PP
Building \s-1WITH_UNICODE\s0 affects columns and parameters which are
\&\s-1SQL_C_WCHAR, SQL_WCHAR, SQL_WVARCHAR,\s0 and \s-1SQL_WLONGVARCHAR, SQL,\s0
the connect method and a lot more. See \*(L"Unicode\*(R".
.PP
When odbc_has_unicode is 1, \s-1DBD::ODBC\s0 will:
.IP "bind all string columns as wide characters (SQL_Wxxx)" 4
.IX Item "bind all string columns as wide characters (SQL_Wxxx)"
This means that \s-1UNICODE\s0 data stored in these columns will be returned
to Perl correctly as unicode (i.e., encoded in \s-1UTF\-8\s0 and the \s-1UTF\-8\s0 flag set).
.IP "bind parameters the database declares as wide characters or unicode parameters as SQL_Wxxx" 4
.IX Item "bind parameters the database declares as wide characters or unicode parameters as SQL_Wxxx"
Parameters bound where the database declares the parameter as being a
wide character, or where the parameter data is unicode, or where the
parameter type is explicitly set to a wide type (e.g., SQL_Wxxx) are bound
as wide characters in the \s-1ODBC API\s0 and \s-1DBD::ODBC\s0 encodes the perl parameters
as \s-1UTF\-16\s0 before passing them to the driver.
.IP "\s-1SQL\s0" 4
.IX Item "SQL"
\&\s-1SQL\s0 passed to the \f(CW\*(C`prepare\*(C'\fR or \f(CW\*(C`do\*(C'\fR methods which has the \s-1UTF\-8\s0 flag
set will be converted to \s-1UTF\-16\s0 before being passed to the \s-1ODBC\s0 APIs
\&\f(CW\*(C`SQLPrepare\*(C'\fR or \f(CW\*(C`SQLExecDirect\*(C'\fR.
.IP "connection strings" 4
.IX Item "connection strings"
Connection strings passed to the \f(CW\*(C`connect\*(C'\fR method will be converted
to \s-1UTF\-16\s0 before being passed to the \s-1ODBC API\s0
\&\f(CW\*(C`SQLDriverConnectW\*(C'\fR. This happens irrespective of whether the \s-1UTF\-8\s0
flag is set on the perl connect strings because unixODBC requires an
application to call SQLDriverConnectW to indicate it will be calling
the wide \s-1ODBC\s0 APIs.
.PP
\&\s-1NOTE:\s0 You will need at least Perl 5.8.1 to use \s-1UNICODE\s0 with \s-1DBD::ODBC.\s0
.PP
\&\s-1NOTE:\s0 Binding of unicode output parameters is coded but untested.
.PP
\&\s-1NOTE:\s0 When building \s-1DBD::ODBC\s0 on Windows ($^O eq 'MSWin32') the
\&\s-1WITH_UNICODE\s0 macro is automatically added. To disable specify \-nou as
an argument to Makefile.PL (e.g. \f(CW\*(C`perl Makefile.PL \-nou\*(C'\fR). On non-Windows
platforms the \s-1WITH_UNICODE\s0 macro is \fBnot\fR enabled by default and to enable
you need to specify the \-u argument to Makefile.PL. Please bear in mind
that some \s-1ODBC\s0 drivers do not support SQL_Wxxx columns or parameters.
.PP
\&\s-1UNICODE\s0 support in \s-1ODBC\s0 Drivers differs considerably. Please read the
\&\s-1README\s0.unicode file for further details.
.PP
\fIodbc_out_connect_string\fR
.IX Subsection "odbc_out_connect_string"
.PP
After calling the connect method this will be the \s-1ODBC\s0 driver's
out connection string \- see documentation on SQLDriverConnect.
.PP
\&\fB\s-1NOTE\s0\fR: this value is only set if \s-1DBD::ODBC\s0 calls the
SQLDriverConnect \s-1ODBC API\s0 (and not SQLConnect) which only happens if a) \s-1DSN\s0 or
\&\s-1DRIVER\s0 is specified in the connection string or b) SQLConnect fails.
.PP
Typically, applications (like \s-1MS\s0 Access and many others) which build a connection string via
dialogs and possibly SQLBrowseConnect eventually end up with a successful \s-1ODBC\s0 connection
to the \s-1ODBC\s0 driver and database. The odbc_out_connect_string provides a string
which you can pass to SQLDriverConnect (\s-1DBI\s0's connect prefixed with dbi:ODBC:") which
will connect you to the same datasource at a later date. You may also want to see
\&\*(L"odbc_driver_complete\*(R".
.PP
\fIodbc_version\fR
.IX Subsection "odbc_version"
.PP
This was added prior to the move to \s-1ODBC 3\s0.x to allow the caller to
\&\*(L"force\*(R" \s-1ODBC 3.0\s0 compatibility.  It's probably not as useful now, but
it allowed get_info and get_type_info to return correct/updated
information that \s-1ODBC 2\s0.x didn't permit/provide.  Since \s-1DBD::ODBC\s0 is
now 3.x, this can be used to force 2.x behavior via something like: my
.PP
.Vb 2
\&  $dbh = DBI\->connect("dbi:ODBC:$DSN", $user, $pass,
\&                      { odbc_version =>2});
.Ve
.PP
\fIodbc_driver_complete\fR
.IX Subsection "odbc_driver_complete"
.PP
This attribute was added to \s-1DBD::ODBC\s0 in 1.32_2.
.PP
odbc_driver_complete is only relevant to the Windows operating system
and will be ignored on other platforms. It is off by default.
.PP
When set to a true value \s-1DBD::ODBC\s0 attempts to obtain a window handle
and calls SQLDriverConnect with the \s-1SQL_DRIVER_COMPLETE\s0 attribute
instead of the normal \s-1SQL_DRIVER_NOPROMPT\s0 option. What this means is
that if the connection string does not describe sufficient attributes
to enable the \s-1ODBC\s0 driver manager to connect to a data source it will
throw a dialogue allowing you to input the remaining attributes. Once
you ok that dialogue the \s-1ODBC\s0 Driver Manager will continue as if you
specified those attributes in the connection string. Once the
connection is complete you may want to look at the odbc_out_connect_string
attribute to obtain a connection string you can use in the future to
pass into the connect method without prompting.
.PP
As a window handle is passed to SQLDriverConnect it also means the
\&\s-1ODBC\s0 driver may throw a dialogue e.g., if your password has expired
the \s-1MS SQL\s0 Server driver will often prompt for a new one.
.PP
An example is:
.PP
.Vb 2
\&  my $h = DBI\->connect(\*(Aqdbi:ODBC:DRIVER={SQL Server}\*(Aq, "username", "password",
\&                       {odbc_driver_complete => 1});
.Ve
.PP
As this only provides the driver and further attributes are required a
dialogue will be thrown allowing you to specify the \s-1SQL\s0 Server to
connect to and possibly other attributes.
.PP
\fIodbc_batch_size\fR
.IX Subsection "odbc_batch_size"
.PP
Sets the batch size for execute_for_fetch which defaults to 10.
Bear in mind the bigger you set this the more memory \s-1DBD::ODBC\s0 will need
to allocate when running execute_for_fetch and the memory required is
max_length_of_pn * odbc_batch_size * n_parameters.
.PP
\fIodbc_array_operations\fR
.IX Subsection "odbc_array_operations"
.PP
\&\s-1NOTE:\s0 this was briefly odbc_disable_array_operations in 1.35 and 1.36_1.
I did warn it was experimental and it turned out the default was too
ambitious and it was a poor name anyway. Also the default was to use
array operations and now the default is the opposite.
.PP
If set to true \s-1DBD::ODBC\s0 uses its own internal execute_for_fetch
instead of \s-1DBI\s0's default execute_for_fetch. The default is false.
Using the internal execute_for_fetch should be quite a bit faster when
using arrays of parameters for insert/update/delete operations as
batches of parameters are sent to the database in one go. However,
the required support in some \s-1ODBC\s0 drivers is a little sketchy and there
is no way for \s-1DBD::ODBC\s0 to ascertain this until it is too late.
.PP
Please read the documentation on execute_array and execute_for_fetch
which details subtle differences in \s-1DBD::ODBC\s0's implementation compared
with using \s-1DBI\s0's default implementation. If these difference cause you
a problem you can set odbc_array_operations to false and \s-1DBD::ODBC\s0
will revert to \s-1DBI\s0's implementations of the array methods.
.PP
You can use the environment variable \s-1ODBC_DISABLE_ARRAY_OPERATIONS\s0 to
switch array operations on/off too. When set to 1 array operations are
disabled. When not set the default is used (which currently is off).
When set to 0 array operations are used no matter what. I know this is
slightly counter intuitive but I've found it difficult to change the
name (it got picked up and used in a few places very quickly).
.PP
\fIodbc_taf_callback\fR
.IX Subsection "odbc_taf_callback"
.PP
\&\s-1NOTE:\s0 this is experimental until I at least see more than one \s-1ODBC\s0
driver which supports \s-1TAF.\s0
.PP
Transparent Application Failover (\s-1TAF\s0) is a feature in \s-1OCI\s0 that
allows for clients to automatically reconnect to an instance in the
event of a failure of the instance. The reconnect happens
automatically from within the \s-1OCI\s0 (Oracle Call Interface)
library.
.PP
\&\s-1TAF\s0 supports a callback function which once registered is called
by the driver to let you know what is happening and which allows
you to a degree, to control how the failover is handled.
.PP
You need to set up \s-1TAF\s0 on your instance first and that process
is beyond the scope of this document. Once \s-1TAF\s0 is enabled you simply
set \f(CW\*(C`odbc_taf_callback\*(C'\fR to a code reference which should look like
this:
.PP
.Vb 4
\&  sub taf_handler {
\&   my ($dbh, $event, $type) = @_;
\&   # do something here
\&  }
.Ve
.PP
\&\s-1DBD::ODBC\s0 will pass the connection handle ($dbh), the Oracle event
type (\s-1OCI_FO_END, OCI_FO_ABORT, OCI_FO_REAUTH, OCI_FO_BEGIN,
OCI_FO_ERROR\s0) and the Oracle type (\s-1OCI_FO_NONE, OCI_FO_SESSION,
OCI_FO_SELECT, OCI_FO_TXNAL\s0).  Consult the Oracle documentation for
what these are. You can import these constants using the :taf export
tag. If your instance is not \s-1TAF\s0 enabled it is likely an attempt to
register a callback will fail but this is driver dependent (all
\&\s-1DBD::ODBC\s0 does is make a SQLSetConnectAttr call and provide a C
wrapper which calls your Perl subroutine).
.PP
Here is a commented example:
.PP
.Vb 7
\&  my $h = DBI\->connect(\*(Aqdbi:ODBC:oracle\*(Aq,\*(Aqxxx\*(Aq,\*(Aqyyy\*(Aq,
\&                       {RaiseError => 1,
\&                        odbc_taf_callback => \e&taf_handler}) or die "connect";
\&  while (1) {
\&      my $s = $h\->selectall_arrayref(q/select 1 from dual/);
\&      sleep 5;
\&  }
\&
\&  sub taf_handler {
\&     my ($dbh, $event, $type) = @_;
\&
\&     #print "taf_handler $dbh, $event, $type\en";
\&
\&     if ($event == OCI_FO_BEGIN) {
\&         print "Instance unavailable, stand by\en";
\&         print "Your TAF type is : ",
\&             ($type == OCI_FO_NONE ? "NONE" :
\&                  ($type == OCI_FO_SESSION ? "SESSION" :
\&                       ($type == OCI_FO_SELECT ? "SELECT" : "?"))) , "\en";
\&         # start a counter and each time OCI_FO_ERROR is passed in we will
\&         # count down and abort the failover when we hit 0.
\&         $count = 10;
\&         return 0;
\&     } elsif ($event == OCI_FO_ERROR) {
\&         # We get an OCI_FO_ERROR each time the failover fails
\&         # sleep a while until the count hits 0
\&         if (\-\-$count < 1) {
\&             print "Giving up\en";
\&             return 0;            # give up
\&         } else {
\&             print "Retrying...\en";
\&             sleep 1;
\&             return OCI_FO_RETRY; # tell Oracle to retry
\&         }
\&     } elsif ($event == OCI_FO_REAUTH) {
\&         print "Failed over user. Resuming Services\en";
\&     } elsif ($event == OCI_FO_END) {
\&         print "Failover ended \- resuming\en";
\&     }
\&     return 0;
\&  }
.Ve
.PP
\&\s-1NOTE:\s0 The above example is for use with the Easysoft Oracle \s-1ODBC\s0
Driver. \s-1ODBC\s0 does not define any standard way of supporting \s-1TAF\s0 and so
different drivers may use different connection attributes to set it up
or may even pass the callback different arguments. Unfortunately, I
don't have access to any other \s-1ODBC\s0 driver which supports \s-1TAF.\s0 Until I
see others I cannot create a generic interface. I'll happily accept
patches for any other driver or if you send me a working copy of the
driver and the documentation I will add support for it.
.PP
\fIodbc_trace_file\fR
.IX Subsection "odbc_trace_file"
.PP
Specify the name and path to a file you want \s-1ODBC API\s0 trace
information to be written to. See \*(L"odbc_trace\*(R".
.PP
\fIodbc_trace\fR
.IX Subsection "odbc_trace"
.PP
Enable or disable \s-1ODBC API\s0 tracing. Set to 1 to enable and 0 to
disable.
.PP
This calls SQLSetConnectAttr for \s-1SQL_ATTR_TRACE\s0 and either sets
\&\s-1SQL_OPT_TRACE_ON\s0 or \s-1SQL_OPT_TRACE_OFF.\s0 Enabling tracing will tell
the \s-1ODBC\s0 driver manager to write and \s-1ODBC API\s0 trace to the file
named with \*(L"odbc_trace_file\*(R".
.PP
\&\s-1NOTE:\s0 If you don't set odbc_trace_file most \s-1ODBC\s0 Driver Managers write
to a file called \s-1SQL.LOG\s0 in the root directory (but this depends on
the driver manager used).
.PP
\&\s-1NOTE:\s0 This tracing is produced by the \s-1ODBC\s0 Driver Manager and has
nothing to do with \s-1DBD::ODBC\s0 other than it should trace the \s-1ODBC\s0
calls \s-1DBD::ODBC\s0 makes i.e., \s-1DBD::ODBC\s0 is not responsible for the
tracing mechanism itself.
.PP
\&\s-1NOTE:\s0 Enabling tracing will probably slow your application down a lot.
I'd definitely think twice about it if in a production environment
unless you are desperate as it tends to produce very large trace
files for short periods of \s-1ODBC\s0 activity.
.SS "Private statement attributes"
.IX Subsection "Private statement attributes"
\fIodbc_more_results\fR
.IX Subsection "odbc_more_results"
.PP
Use this attribute to determine if there are more result sets
available.
.PP
Any \s-1ODBC\s0 Driver which batches results or counts of inserts/updates
will need you to loop on odbc_more_results until there are no more
results. e.g., if you are performing multiple selects in a procedure or
multiple inserts/updates/deletes then you will probably need to loop on
odbc_more_results.
.PP
Use odbc_more_results as follows:
.PP
.Vb 6
\&  do {
\&     my @row;
\&     while (@row = $sth\->fetchrow_array()) {
\&        # do stuff here
\&     }
\&  } while ($sth\->{odbc_more_results});
.Ve
.PP
Note that with multiple result sets and output parameters (i.e,. using
bind_param_inout), don't expect output parameters to written to until \s-1ALL\s0
result sets have been retrieved.
.PP
Under the hood this attribute causes a call to the \s-1ODBC API\s0
SQLMoreResults and then any result set, insert/update/delete or output
parameters are described by \s-1DBD::ODBC\s0 and the statement handle will be
ready for processing the new result.
.SS "Private statement methods"
.IX Subsection "Private statement methods"
\fIodbc_rows\fR
.IX Subsection "odbc_rows"
.PP
This method was added in 1.42_1.
.PP
In 64 bit \s-1ODBC\s0 SQLRowCount can return a 64bit value for the number of
rows affected. Unfortunately, the \s-1DBI DBD\s0 interface currently (at
least until 1.622) defines execute as returning an int so values which
cannot fit in an int are truncated. See \s-1RT 81911.\s0
.PP
From \s-1DBD::ODBC 1.42_1 DBD::ODBC\s0
.PP
o defines this method which will return the affected rows in an \s-1IV\s0
(and IVs are guaranteed to be able to hold a pointer) so you
can get the real affected rows without truncation.
.PP
o if it detects an overflow in the execute method it will issue
a warning (if Warn is on which it is by default) and return \s-1INT_MAX.\s0
.PP
At some stage \s-1DBI\s0 may change to fix the issue this works around.
.PP
\&\s-1NOTE:\s0 the return from odbc_rows is not the raw value returned by
SQLRowCount. It is the same as execute normally returns e.g., 0E0 (for
0), \-1 for unknown and N for N rows affected where N > 0.
.PP
\fIodbc_lob_read\fR
.IX Subsection "odbc_lob_read"
.PP
.Vb 1
\&  $chrs_or_bytes_read = $sth\->odbc_lob_read($column_no, \e$lob, $length, \e%attr);
.Ve
.PP
Reads \f(CW$length\fR bytes from the lob at column \f(CW$column_no\fR returning
the lob into \f(CW$lob\fR and the number of bytes or characters read into
\&\f(CW$chrs_or_bytes_read\fR. If an error occurs undef will be returned.
When there is no more data to be read 0 is returned.
.PP
\&\s-1NOTE:\s0 This is currently an experimental method and may change in the
future e.g., it may support automatic concatenation of the lob
parts onto the end of the \f(CW$lob\fR with the addition of an extra flag
or destination offset as in \s-1DBI\s0's undocumented blob_read.
.PP
The type the lob is retrieved as may be overridden in \f(CW%attr\fR using
\&\f(CW\*(C`TYPE => sql_type\*(C'\fR. \f(CW%attr\fR is optional and if omitted defaults
to \s-1SQL_C_BINARY\s0 for binary columns and \s-1SQL_C_CHAR/SQL_C_WCHAR\s0 for
other column types depending on whether \s-1DBD::ODBC\s0 is built with
unicode support. \f(CW$chrs_or_bytes_read\fR will by the bytes read when
the column types \s-1SQL_C_CHAR\s0 or \s-1SQL_C_BINARY\s0 are used and characters
read if the column type is \s-1SQL_C_WCHAR.\s0
.PP
When built with unicode support \f(CW$length\fR specifies the amount of
buffer space to be used when retrieving the lob data but as it is
returned as \s-1SQLWCHAR\s0 characters this means you at most retrieve
\&\f(CW\*(C`$length/2\*(C'\fR characters. When those retrieved characters are encoded
in \s-1UTF\-8\s0 for Perl, the \f(CW$lob\fR scalar may need to be larger than
\&\f(CW$length\fR so \s-1DBD::ODBC\s0 grows it appropriately.
.PP
You can retrieve a lob in chunks like this:
.PP
.Vb 4
\&  $sth\->bind_col($column, undef, {TreatAsLOB=>1});
\&  while(my $retrieved = $sth\->odbc_lob_read($column, \emy $data, $length)) {
\&      print "retrieved=$retrieved lob_data=$data\en";
\&  }
.Ve
.PP
\&\s-1NOTE:\s0 to retrieve a lob like this you \fBmust\fR first bind the lob
column specifying BindAsLOB or \s-1DBD::ODBC\s0 will 1) bind the column as
normal and it will be subject to LongReadLen and b) fail
odbc_lob_read.
.PP
\&\s-1NOTE:\s0 Some database engines and \s-1ODBC\s0 drivers do not allow you to
retrieve columns out of order (e.g., \s-1MS SQL\s0 Server unless you are
using cursors).  In those cases you must ensure the lob retrieved is
the last (or only) column in your select list.
.PP
\&\s-1NOTE:\s0 You can retrieve only part of a lob but you will probably have
to call finish on the statement handle before you do anything else
with that statement. When only retrieving part of a large lob you
could see a small delay when you call finish as some protocols used
by \s-1ODBC\s0 drivers send the lob down the socket synchronously and there is
no way to stop it (this means the \s-1ODBC\s0 driver needs to read all the
lob from the socket even though you never retrieved it all yourself).
.PP
\&\s-1NOTE:\s0 If your select contains multiple lobs you cannot read part of
the first lob, the second lob then return to the first lob. You must
read all lobs in order and completely or read part of a lob and then
do no further calls to odbc_lob_read.
.SS "Private \s-1DBD::ODBC\s0 Functions"
.IX Subsection "Private DBD::ODBC Functions"
You use \s-1DBD::ODBC\s0 private functions like this:
.PP
.Vb 1
\&  $dbh\->func(arg, private_function_name, @args);
.Ve
.PP
\fIGetInfo\fR
.IX Subsection "GetInfo"
.PP
\&\fBThis private function is now superseded by \s-1DBI\s0's get_info method.\fR
.PP
This function maps to the \s-1ODBC\s0 SQLGetInfo call and the argument
should be a valid \s-1ODBC\s0 information type (see \s-1ODBC\s0 specification).
e.g.
.PP
.Vb 1
\&  $value = $dbh\->func(6, \*(AqGetInfo\*(Aq);
.Ve
.PP
which returns the \f(CW\*(C`SQL_DRIVER_NAME\*(C'\fR.
.PP
This function returns a scalar value, which can be a numeric or string
value depending on the information value requested.
.PP
\fIGetTypeInfo\fR
.IX Subsection "GetTypeInfo"
.PP
\&\fBThis private function is now superseded by \s-1DBI\s0's type_info and
type_info_all methods however as it is used by those methods it
still exists.\fR
.PP
This function maps to the \s-1ODBC\s0 SQLGetTypeInfo \s-1API\s0 and the argument
should be a \s-1SQL\s0 type number (e.g. \s-1SQL_VARCHAR\s0) or
\&\s-1SQL_ALL_TYPES.\s0 SQLGetTypeInfo returns information about a data type
supported by the data source.
.PP
e.g.
.PP
.Vb 1
\&  use DBI qw(:sql_types);
\&
\&  $sth = $dbh\->func(SQL_ALL_TYPES, GetTypeInfo);
\&  DBI::dump_results($sth);
.Ve
.PP
This function returns a \s-1DBI\s0 statement handle for the SQLGetTypeInfo
result-set containing many columns of type attributes (see \s-1ODBC\s0
specification).
.PP
\&\s-1NOTE:\s0 It is \s-1VERY\s0 important that the \f(CW\*(C`use DBI\*(C'\fR includes the
\&\f(CW\*(C`qw(:sql_types)\*(C'\fR so that values like \s-1SQL_VARCHAR\s0 are correctly
interpreted.  This \*(L"imports\*(R" the sql type names into the program's
name space.  A very common mistake is to forget the \f(CW\*(C`qw(:sql_types)\*(C'\fR
and obtain strange results.
.PP
\fIGetFunctions\fR
.IX Subsection "GetFunctions"
.PP
This function maps to the \s-1ODBC\s0 SQLGetFunctions \s-1API\s0 which returns
information on whether a function is supported by the \s-1ODBC\s0 driver.
.PP
The argument should be \f(CW\*(C`SQL_API_ALL_FUNCTIONS\*(C'\fR (0) for all functions
or a valid \s-1ODBC\s0 function number (e.g. \f(CW\*(C`SQL_API_SQLDESCRIBEPARAM\*(C'\fR
which is 58). See \s-1ODBC\s0 specification or examine your sqlext.h and
sql.h header files for all the \s-1SQL_API_XXX\s0 macros.
.PP
If called with \f(CW\*(C`SQL_API_ALL_FUNCTIONS\*(C'\fR (0), then a 100 element array is
returned where each element will contain a '1' if the \s-1ODBC\s0 function with
that \s-1SQL_API_XXX\s0 index is supported or '' if it is not.
.PP
If called with a specific \s-1SQL_API_XXX\s0 value for a single function it will
return true if the \s-1ODBC\s0 driver supports that function, otherwise false.
.PP
e.g.
.PP
.Vb 2
\&    my @x = $dbh\->func(0,"GetFunctions");
\&    print "SQLDescribeParam is supported\en" if ($x[58]);
.Ve
.PP
or
.PP
.Vb 2
\&    print "SQLDescribeParam is supported\en"
\&        if $dbh\->func(58, "GetFunctions");
.Ve
.PP
\fIGetStatistics\fR
.IX Subsection "GetStatistics"
.PP
\&\fBThis private function is now superseded by \s-1DBI\s0's statistics_info
method.\fR
.PP
See the \s-1ODBC\s0 specification for the SQLStatistics \s-1API.\s0
You call SQLStatistics like this:
.PP
.Vb 1
\&  $dbh\->func($catalog, $schema, $table, $unique, \*(AqGetStatistics\*(Aq);
.Ve
.PP
Prior to \s-1DBD::ODBC 1.16\s0 \f(CW$unique\fR was not defined as being true/false or
\&\s-1SQL_INDEX_UNIQUE/SQL_INDEX_ALL.\s0 In fact, whatever value you provided
for \f(CW$unique\fR was passed through to the \s-1ODBC API\s0 SQLStatistics call
unchanged. This changed in 1.16, where \f(CW$unique\fR became a true/false
value which is interpreted into \s-1SQL_INDEX_UNIQUE\s0 for true and
\&\s-1SQL_INDEX_ALL\s0 for false.
.PP
\fIGetForeignKeys\fR
.IX Subsection "GetForeignKeys"
.PP
\&\fBThis private function is now superseded by \s-1DBI\s0's foreign_key_info
method.\fR
.PP
See the \s-1ODBC\s0 specification for the SQLForeignKeys \s-1API.\s0
You call SQLForeignKeys like this:
.PP
.Vb 3
\&  $dbh\->func($pcatalog, $pschema, $ptable,
\&             $fcatalog, $fschema, $ftable,
\&             "GetForeignKeys");
.Ve
.PP
\fIGetPrimaryKeys\fR
.IX Subsection "GetPrimaryKeys"
.PP
\&\fBThis private function is now superseded by \s-1DBI\s0's primary_key_info
method.\fR
.PP
See the \s-1ODBC\s0 specification for the SQLPrimaryKeys \s-1API.\s0
You call SQLPrimaryKeys like this:
.PP
.Vb 1
\&  $dbh\->func($catalog, $schema, $table, "GetPrimaryKeys");
.Ve
.PP
\fIdata_sources\fR
.IX Subsection "data_sources"
.PP
\&\fBThis private function is now superseded by \s-1DBI\s0's data_sources
method and was finally removed in 1.49_1\fR
.PP
\fIGetSpecialColumns\fR
.IX Subsection "GetSpecialColumns"
.PP
See the \s-1ODBC\s0 specification for the SQLSpecialColumns \s-1API.\s0
You call SQLSpecialColumns like this:
.PP
.Vb 2
\&  $dbh\->func($identifier, $catalog, $schema, $table, $scope,
\&             $nullable, \*(AqGetSpecialColumns\*(Aq);
.Ve
.PP
Handled as of version 0.28
.PP
\fIColAttributes\fR
.IX Subsection "ColAttributes"
.PP
\&\fBThis private function is now superseded by \s-1DBI\s0's statement attributes
\&\s-1NAME, TYPE, PRECISION, SCALE, NULLABLE\s0 etc).\fR
.PP
See the \s-1ODBC\s0 specification for the SQLColAttributes \s-1API.\s0
You call SQLColAttributes like this:
.PP
.Vb 1
\&  $sth\->func($column, $ftype, "ColAttributes");
\&
\&  SQL_COLUMN_COUNT = 0
\&  SQL_COLUMN_NAME = 1
\&  SQL_COLUMN_TYPE = 2
\&  SQL_COLUMN_LENGTH = 3
\&  SQL_COLUMN_PRECISION = 4
\&  SQL_COLUMN_SCALE = 5
\&  SQL_COLUMN_DISPLAY_SIZE = 6
\&  SQL_COLUMN_NULLABLE = 7
\&  SQL_COLUMN_UNSIGNED = 8
\&  SQL_COLUMN_MONEY = 9
\&  SQL_COLUMN_UPDATABLE = 10
\&  SQL_COLUMN_AUTO_INCREMENT = 11
\&  SQL_COLUMN_CASE_SENSITIVE = 12
\&  SQL_COLUMN_SEARCHABLE = 13
\&  SQL_COLUMN_TYPE_NAME = 14
\&  SQL_COLUMN_TABLE_NAME = 15
\&  SQL_COLUMN_OWNER_NAME = 16
\&  SQL_COLUMN_QUALIFIER_NAME = 17
\&  SQL_COLUMN_LABEL = 18
.Ve
.PP
\&\fBNote:\fROracle's \s-1ODBC\s0 driver for linux in instant client 11r1 often
returns strange values for column name e.g., '20291'. It is wiser to
use \s-1DBI\s0's \s-1NAME\s0 and NAME_xx attributes for portability.
.PP
\fIDescribeCol\fR
.IX Subsection "DescribeCol"
.PP
Removed in \s-1DBD::ODBC 1.40_3\s0
.PP
Use the \s-1DBI\s0's statement attributes \s-1NAME, TYPE, PRECISION, SCALE,
NULLABLE\s0 etc instead.
.SS "Additional bind_col attributes"
.IX Subsection "Additional bind_col attributes"
\&\s-1DBD::ODBC\s0 supports a few additional attributes which may be passed to
the bind_col method in the attributes.
.PP
\fIDiscardString\fR
.IX Subsection "DiscardString"
.PP
See \s-1DBI\s0's sql_type_cast utility function.
.PP
If you bind a column as a specific type (\s-1SQL_INTEGER, SQL_DOUBLE\s0 and
\&\s-1SQL_NUMERIC\s0 are the only ones supported currently) and you add
DiscardString to the prepare attributes then if the returned bound
data is capable of being converted to that type the scalar's pv (the
string portion of a scalar) is cleared.
.PP
\&\s-1NOTE:\s0 post \s-1DBD::ODBC 1.37, DBD::ODBC\s0 binds all \s-1SQL_INTEGER\s0 columns as
\&\s-1SQL_C_LONG\s0 and DiscardString is irrelevant.
.PP
This is especially useful if you are using a module which uses a
scalar's flags and/or pv to decide if a scalar is a number. \s-1JSON::XS\s0
does this and without this flag you have to add 0 to all bound column
data returning numbers to get \s-1JSON::XS\s0 to encode it is N instead of
\&\*(L"N\*(R".
.PP
\&\s-1NOTE:\s0 For DiscardString you need at least \s-1DBI 1.611.\s0
.PP
\fIStrictlyTyped\fR
.IX Subsection "StrictlyTyped"
.PP
See \s-1DBI\s0's sql_type_cast utility function.
.PP
See \*(L"DiscardString\*(R" above.
.PP
Specifies that when \s-1DBI\s0's sql_type_cast function is called on returned
data where a bind type is specified that if the conversion cannot be
performed an error will be raised.
.PP
This is probably not a lot of use with \s-1DBD::ODBC\s0 as if you ask for say
an \s-1SQL_INTEGER\s0 and the data is not able to be converted to an integer
the \s-1ODBC\s0 driver will probably return \*(L"Invalid character value for
cast specification (\s-1SQL\-22018\s0)\*(R".
.PP
\&\s-1NOTE:\s0 For StrictlyTyped you need at least \s-1DBI 1.611.\s0
.PP
\fITreatAsLOB\fR
.IX Subsection "TreatAsLOB"
.PP
See \*(L"odbc_lob_read\*(R".
.SS "Tracing"
.IX Subsection "Tracing"
\&\s-1DBD::ODBC\s0 now supports the parse_trace_flag and parse_trace_flags
methods introduced in \s-1DBI 1.42\s0 (see \s-1DBI\s0 for a full description).  As
of \s-1DBI 1.604,\s0 the only trace flag defined which is relevant to
\&\s-1DBD::ODBC\s0 is '\s-1SQL\s0' which \s-1DBD::ODBC\s0 supports by outputting the \s-1SQL\s0
strings (after modification) passed to the prepare and do methods.
.PP
From \s-1DBI 1.617 DBI\s0 also defines \s-1ENC\s0 (encoding), \s-1CON\s0 (connection) \s-1TXN\s0
(transaction) and \s-1DBD\s0 (\s-1DBD\s0 only) trace flags. \s-1DBI\s0's \s-1ENC\s0 and \s-1CON\s0 trace
flags are synonymous with \s-1DBD::ODBC\s0's odbcunicode and odbcconnection
trace flags though I may remove the \s-1DBD::ODBC\s0 ones in the
future. \s-1DBI\s0's \s-1DBD\s0 trace flag allows output of only \s-1DBD::ODBC\s0 trace
messages without \s-1DBI\s0's trace messages.
.PP
Currently \s-1DBD::ODBC\s0 supports two private trace flags. The
\&'odbcunicode' flag traces some unicode operations and the
odbcconnection traces the connect process.
.PP
To enable tracing of particular flags you use:
.PP
.Vb 2
\&  $h\->trace($h\->parse_trace_flags(\*(AqSQL|odbcconnection\*(Aq));
\&  $h\->trace($h\->parse_trace_flags(\*(Aq1|odbcunicode\*(Aq));
.Ve
.PP
In the first case '\s-1SQL\s0' and 'odbcconnection' tracing is enabled on
\&\f(CW$h\fR. In the second case trace level 1 is set and 'odbcunicode' tracing
is enabled.
.PP
If you want to enable a \s-1DBD::ODBC\s0 private trace flag before connecting
you need to do something like:
.PP
.Vb 2
\&  use DBD::ODBC;
\&  DBI\->trace(DBD::ODBC\->parse_trace_flag(\*(Aqodbcconnection\*(Aq));
.Ve
.PP
or
.PP
.Vb 2
\&  use DBD::ODBC;
\&  DBI\->trace(DBD::ODBC\->parse_trace_flags(\*(Aqodbcconnection|odbcunicode\*(Aq));
.Ve
.PP
or
.PP
.Vb 1
\&  DBI_TRACE=odbcconnection|odbcunicode perl myscript.pl
.Ve
.PP
From \s-1DBI 1.617\s0 you can output only \s-1DBD::ODBC\s0 trace messages using
.PP
.Vb 1
\&  DBI_TRACE=DBD perl myscript.pl
.Ve
.PP
\&\s-1DBD::ODBC\s0 outputs tracing at levels 3 and above (as levels 1 and 2 are
reserved for \s-1DBI\s0).
.PP
For comprehensive tracing of \s-1DBI\s0 method calls without all the \s-1DBI\s0
internals see DBIx::Log4perl.
.SS "Deviations from the \s-1DBI\s0 specification"
.IX Subsection "Deviations from the DBI specification"
\fIlast_insert_id\fR
.IX Subsection "last_insert_id"
.PP
\&\s-1DBD::ODBC\s0 does not support \s-1DBI\s0's last_insert_id. There is no \s-1ODBC\s0
defined way of obtaining this information. Generally the mechanism
(and it differs vastly between databases and \s-1ODBC\s0 drivers) it to issue
a select of some form (e.g., select @@identity or select
sequence.currval from dual, etc).
.PP
There are literally dozens of databases and \s-1ODBC\s0 drivers supported by
\&\s-1DBD::ODBC\s0 and I cannot have them all. If you know how to retrieve the
information for last_insert_id and you mail me the \s-1ODBC\s0 Driver
name/version and database name/version with a small working example I
will collect examples and document them here.
.PP
\&\fBMicrosoft Access\fR. Recent versions of \s-1MS\s0 Access support \fIselect
@@identity\fR to retrieve the last insert \s-1ID.\s0  See
http://support.microsoft.com/kb/815629. Information provided by Robert
Freimuth.
.PP
\fIComments in \s-1SQL\s0\fR
.IX Subsection "Comments in SQL"
.PP
\&\s-1DBI\s0 does not say anything in particular about comments in \s-1SQL.
DBD::ODBC\s0 looks for placeholders in the \s-1SQL\s0 string and until 1.24_2 it
did not recognise comments in \s-1SQL\s0 strings so could find what it
believes to be a placeholder in a comment e.g.,
.PP
.Vb 3
\&  select \*(Aq1\*(Aq /* placeholder ? in comment */
\&  select \-\- named placeholder :named in comment
\&    \*(Aq1\*(Aq
.Ve
.PP
I cannot be exact about support for ignoring placeholders in literals
but it has existed for a long time in \s-1DBD::ODBC.\s0 Support for ignoring
placeholders in comments was added in 1.24_2. If you find a case where
a named placeholder is not ignored and should be, see
\&\*(L"odbc_ignore_named_placeholders\*(R" for a workaround and mail me an
example along with your \s-1ODBC\s0 driver name.
.PP
\fIdo\fR
.IX Subsection "do"
.PP
This is not really a deviation from the \s-1DBI\s0 specification since \s-1DBI\s0
allows a driver to avoid the overhead of creating an \s-1DBI\s0 statement
handle for \fBdo()\fR.
.PP
\&\s-1DBD::ODBC\s0 implements \f(CW\*(C`do\*(C'\fR by calling SQLExecDirect in \s-1ODBC\s0 and not
SQLPrepare followed by SQLExecute so \f(CW\*(C`do\*(C'\fR is not the same as:
.PP
.Vb 1
\&  $dbh\->prepare($sql)\->execute()
.Ve
.PP
It does this to avoid a round-trip to the server so it is faster.
Normally this is good but some people fall foul of this with \s-1MS SQL\s0
Server if they call a procedure which outputs print statements (e.g.,
backup) as the procedure may not complete. See the \s-1DBD::ODBC FAQ\s0 and
in general you are better to use prepare/execute when calling
procedures.
.PP
In addition, you should realise that since \s-1DBD::ODBC\s0 does not create a
\&\s-1DBI\s0 statement for do calls, if you set up an error handler the handle
passed in when a do fails will be the database handle and not
a statement handle.
.PP
\fIMixed placeholder types\fR
.IX Subsection "Mixed placeholder types"
.PP
There are 3 conventions for place holders in \s-1DBI.\s0 These are '?', ':N'
and ':name' (where 'N' is a number and 'name' is an alpha numeric
string not beginning with a number). \s-1DBD::ODBC\s0 supports all these methods
for naming placeholders but you must only use one method throughout
a particular \s-1SQL\s0 string. If you mix placeholder methods you will get
an error like:
.PP
.Vb 1
\&  Can\*(Aqt mix placeholder styles (1/2)
.Ve
.PP
\fIUsing the same placeholder more than once\fR
.IX Subsection "Using the same placeholder more than once"
.PP
\&\s-1DBD::ODBC\s0 does not support (currently) the use of one named placeholder
more than once in a single \s-1SQL\s0 string. i.e.,
.PP
.Vb 1
\&  insert into foo values (:bar, :p1, :p2, :bar);
.Ve
.PP
is not supported because 'bar' is used more than once but:
.PP
.Vb 1
\&  insert into foo values(:bar, :p1, :p2)
.Ve
.PP
is ok. If you do the former you will get an error like:
.PP
.Vb 1
\&  DBD::ODBC does not yet support binding a named parameter more than once
.Ve
.PP
\fIBinding named placeholders\fR
.IX Subsection "Binding named placeholders"
.PP
Although the \s-1DBI\s0 documentation (as of 1.604) does not say how named
parameters are bound Tim Bunce has said that in Oracle they are bound
with the leading ':' as part of the name and that has always been the
case. i.e.,
.PP
.Vb 2
\&  prepare("insert into mytable values (:fred)");
\&  bind_param(":foo", 1);
.Ve
.PP
\&\s-1DBD::ODBC\s0 does not support binding named parameters with the ':' introducer.
In the above example you must use:
.PP
.Vb 1
\&  bind_param("foo", 1);
.Ve
.PP
In discussion on the dbi-dev list is was suggested that the ':' could
be made optional and there were no basic objections but it has not
made it's way into the pod yet.
.PP
\fISticky Parameter Types\fR
.IX Subsection "Sticky Parameter Types"
.PP
The \s-1DBI\s0 specification post 1.608 says in bind_param:
.PP
.Vb 4
\&  The data type is \*(Aqsticky\*(Aq in that bind values passed to execute()
\&  are bound with the data type specified by earlier bind_param()
\&  calls, if any.  Portable applications should not rely on being able
\&  to change the data type after the first bind_param call.
.Ve
.PP
\&\s-1DBD::ODBC\s0 does allow a parameter to be rebound with another data type as
\&\s-1ODBC\s0 inherently allows this. Therefore you can do:
.PP
.Vb 9
\&  # parameter 1 set as a SQL_LONGVARCHAR
\&  $sth\->bind_param(1, $data, DBI::SQL_LONGVARCHAR);
\&  # without the bind above the $data parameter would be either a DBD::ODBC
\&  # internal default or whatever the ODBC driver said it was but because
\&  # parameter types are sticky, the type is still SQL_LONGVARCHAR.
\&  $sth\->execute($data);
\&  # change the bound type to SQL_VARCHAR
\&  # some DBDs will ignore the type in the following, DBD::ODBC does not
\&  $sth\->bind_param(1, $data, DBI::SQL_VARCHAR);
.Ve
.PP
\fIdisconnect and transactions\fR
.IX Subsection "disconnect and transactions"
.PP
\&\s-1DBI\s0 does not define whether a driver commits or rolls back any
outstanding transaction when disconnect is called. As such \s-1DBD::ODBC\s0
cannot deviate from the specification but you should know it rolls
back an uncommitted transaction when disconnect is called if
SQLDisconnect returns state 25000 (transaction in progress).
.PP
\fIexecute_for_fetch and execute_array\fR
.IX Subsection "execute_for_fetch and execute_array"
.PP
From version 1.34_1 \s-1DBD::ODBC\s0 implements its own execute_for_fetch
which binds arrays of parameters and can send multiple rows
(\*(L"odbc_batch_size\*(R") of parameters through the \s-1ODBC\s0 driver in one go
(this overrides \s-1DBI\s0's default execute_for_fetch). This is much faster
when inserting, updating or deleting many rows in one go. Note,
execute_array uses execute_for_fetch when the parameters are passed
for column-wise binding.
.PP
\&\s-1NOTE: DBD::ODBC 1.34_1\s0 to \s-1DBD::ODBC 1.36_1\s0 set the default to use
\&\s-1DBD::ODBC\s0's own execute_for_fetch but quite a few \s-1ODBC\s0 drivers just
cannot handle it. As such, from \s-1DBD::ODBC 1.36_2\s0 the default was
changed to not use \s-1DBD::ODBC\s0's execute_for_fetch (i.e., you need to
enable it with \*(L"odbc_array_operations\*(R").
.PP
\&\s-1NOTE:\s0 Some \s-1ODBC\s0 drivers don't support setting \s-1SQL_ATTR_PARAMSET_SIZE\s0 >
1, and hence cannot support binding arrays of parameters. The only way
to detect this is to attempt to set \s-1SQL_ATTR_PARAMSET_SIZE\s0 to a value
greater than 1 and it is too late once someone has called
execute_for_fetch. I don't want to add test code on each connect to
test for this as it will affect everyone, even those not using the
native execute_for_fetch so for now it is a suck it and see. For your
information \s-1MS\s0 Access which does not support arrays of parameters
errors with \s-1HY092,\s0 \*(L"Invalid attribute/option identifier\*(R".
.PP
However, there are a small number of differences between using
\&\s-1DBD::ODBC\s0's execute_for_fetch compared with using \s-1DBI\s0's default
implementation (which simply calls execute repeatedly once per row).
The differences you may see are:
.PP
o as \s-1DBI\s0's execute_for_fetch does one row at a time the result from
execute is for one row and just about all \s-1ODBC\s0 drivers can report the
number of affected rows when SQLRowCount is called per execute. When
batches of parameters are sent the driver can still return the number
of affected rows but it is usually per batch rather than per row. As a
result, the tuple_status array you may pass to execute_for_fetch (or
execute_array) usually shows \-1 (unknown) for each row although the total
affected returned in array context is a correct total affected.
.PP
o not all \s-1ODBC\s0 drivers have sufficient \s-1ODBC\s0 support (arguably a bug)
for correct diagnostics support when using arrays. \s-1DBI\s0 dictates that
if a row in the batch is in error the tuple_status will contain the
state, native and error message text. However the batch may generate
multiple errors per row (which \s-1DBI\s0 says nothing about) and more than
one row may error. In \s-1ODBC\s0 we get a list of errors but to associate
each one with a particular row we need to call SQLGetDiagField for
\&\s-1SQL_DIAG_ROW_NUMBER\s0 and it should say which row in the batch the
diagnostic is associated with. Some \s-1ODBC\s0 drivers do not support
\&\s-1SQL_DIAG_ROW_NUMBER\s0 properly and then \s-1DBD::ODBC\s0 cannot know which row
in the batch an error refers to. In this case \s-1DBD::ODBC\s0 will report an
error saying \*(L"failed to retrieve diags\*(R", state of \s-1HY000\s0 and a native
of 1 so you'll still see an error but not necessarily the exact
one. Also, when more than one diagnostic is found for a row \s-1DBD::ODBC\s0
picks the first one (which is usually most relevant) as there is no
way to report more than one diagnostic per row in the tuple_status. If
the first problem of \s-1SQL_DIAG_ROW_NUMBER\s0 proves to be a problem for
you the \s-1DBD::ODBC\s0 tracing will show all errors and you can also use
\&\*(L"odbc_getdiagrec\*(R" yourself.
.PP
o Binding parameters with execute_array and execute_for_fetch does not
allow the parameter types to be set. However, as parameter types are sticky
you can call bind_param(param_num, undef, {\s-1TYPE\s0 => sql_type}) before
calling execute_for_fetch/execute_array and the \s-1TYPE\s0 should be sticky
when the batch of parameters is bound.
.PP
o Although you can insert very large columns execute_for_fetch will
need \*(L"odbc_batch_size\*(R" * max length of parameter per parameter so
you may hit memory limits. If you use \s-1DBI\s0's execute_for_fetch
\&\s-1DBD::ODBC\s0 uses the \s-1ODBC API\s0 SQLPutData (see \*(L"odbc_putdata_start\*(R")
which does not require large amounts of memory as large columns are
sent in pieces.
.PP
o A lot of drivers have bugs with arrays of parameters (see the \s-1ODBC
FAQ\s0). e.g., as of 18\-MAR\-2012 I've seen the latest SQLite \s-1ODBC\s0 driver
seg fault and freeTDS 8/0.91 returns the wrong row count for batches.
.PP
o \fB\s-1DO NOT\s0\fR attempt to do an insert/update/delete and a select in the
same \s-1SQL\s0 with execute_array e.g.,
.PP
.Vb 4
\&  SET IDENTITY_INSERT mytable ON
\&  insert into mytable (id, name) values (?,?)
\&  SET IDENTITY_INSERT mytable OFF
\&  SELECT SCOPE_IDENTITY()
.Ve
.PP
It just won't/can't work although you may not have noticed when using
\&\s-1DBI\s0's inbuilt execute_* methods. See rt 75687.
.PP
\fItype_info_all\fR
.IX Subsection "type_info_all"
.PP
Many \s-1ODBC\s0 drivers now return 20 columns in type_info_all rather than
the 19 \s-1DBI\s0 documents. The 20th column is usually called
\&\*(L"\s-1USERTYPE\*(R".\s0  Recent \s-1MS SQL\s0 Server \s-1ODBC\s0 drivers do this. Fortunately
this should not adversely affect you so long as you are using the keys
provided at the start of type_info_all.
.PP
\fIBinding Columns\fR
.IX Subsection "Binding Columns"
.PP
The \s-1DBI\s0 specification allows a column type to be overridden in the call
to the bind_col method. Mostly, \s-1DBD::ODBC\s0 ignores this type as it
binds integers (\s-1SQL_INTEGER\s0) as a \s-1SQL_C_LONG\s0 (since \s-1DBD::ODBC 1.38_1\s0)
and all other columns as \s-1SQL_C_CHAR\s0 or \s-1SQL_C_WCHAR\s0 and it is too late
to change the bind type after the result-set has been described
anyway. The only time when the \s-1TYPE\s0 passed to bind_col is used in
\&\s-1DBD::ODBC\s0 is when it is \s-1SQL_NUMERIC\s0 or \s-1SQL_DOUBLE\s0 in which case
\&\s-1DBD::ODBC\s0 will call \s-1DBI\s0's sql_type_cast method.
.PP
Since \s-1DBD::ODBC 1.38_1\s0 if you attempt to change the bind type after
the column has already bound \s-1DBD::ODBC\s0 will issue a warning and ignore
your column type change e.g.,
.PP
.Vb 6
\&  my $s = $h\->prepare(q/select a from mytable);
\&  $s\->execute;  # The column type was determined here
\&  my $r;
\&  $s\->bind_col(1, \e$r); # and bound as the right type here
\&  $s\->execute;
\&  $s\->bind_col(1, \e$r, {TYPE => SQL_XXX}); # warning, type changed
.Ve
.PP
Basically, if you are passing a \s-1TYPE\s0 to bind_col with \s-1DBD::ODBC\s0 (other
than \s-1SQL_NUMERIC\s0 or \s-1SQL_DOUBLE\s0) your code is probably wrong.
.PP
Significant changes occurred in \s-1DBD::ODBC\s0 at 1.38_1 for binding
columns. Please see the Changes file.
.PP
\fIbind_param\fR
.IX Subsection "bind_param"
.PP
\&\s-1DBD::ODBC\s0 follows the \s-1DBI\s0 specification for bind_param however the
third argument (a type or a hashref containing a type) is loosely
defined by \s-1DBI.\s0 From the \s-1DBI\s0 pod:
.PP
\&\fIThe \e%attr parameter can be used to hint at the data type the placeholder should have. This is rarely needed. \fR
.PP
As a general rule, don't specify a type when calling bind_param. If you stick to inserting appropriate data into the appropriate column \s-1DBD::ODBC\s0 will mostly do the right thing especially if the \s-1ODBC\s0 driver supports SQLDescribeParam.
.PP
In particular don't just add a type of \s-1SQL_DATE\s0 because you are inserting a date (it will not work). The correct syntax in \s-1ODBC\s0 for inserting dates, times and timestamps is:
.PP
insert into mytable (mydate, mttime, mytimestamp) values(?,?,?);
bind_param(1, \*(L"{d '\s-1YYYY\-MM\-DD\s0'}\*(R");
bind_param(2, \*(L"{t '\s-1HH:MM:SS.MM\s0'}\*(R"); # :MM can be omitted and some dbs support :MMM
bind_param(3, \*(L"{ts '\s-1YYYY\-MM\-DD HH:MM:SS\s0'}\*(R");
.PP
See http://technet.microsoft.com/en\-US/library/ms190234%28v=SQL.90%29.aspx
.PP
The only times when you might want to add a type are:
.PP
1. If your \s-1ODBC\s0 driver does not support SQLDescribeParam (or if you
told \s-1DBD::ODBC\s0 not to use it) then \s-1DBD::ODBC\s0 will default to inserting
each parameter as a string (which is usually the right thing
anyway). This is ok, most of the time, but is probably not what you
want when inserting a binary (use \s-1TYPE\s0 => \s-1SQL_BINARY\s0).
.PP
2. If for some reason your driver describes the parameter
incorrectly. It is difficult to describe an example of this.
.PP
3. If SQLDescribeParam is supported but fails e.g., \s-1MS SQL\s0 Server has
problems with \s-1SQL\s0 like \*(L"select myfunc(?) where 1 = 1\*(R".
.PP
Also, \s-1DBI\s0 exports some types which are not available in \s-1ODBC\s0 e.g.,
\&\s-1SQL_BLOB.\s0 If you are unsure about \s-1ODBC\s0 types look at your \s-1ODBC\s0 header
files or look up valid types in the \s-1ODBC\s0 specification.
.PP
\fItables and table_info\fR
.IX Subsection "tables and table_info"
.PP
These are not really deviations from the \s-1DBI\s0 specification but a
clarification of a \s-1DBI\s0 optional feature.
.PP
\&\s-1DBD::ODBC\s0 supports wildcards (% and _) in the catalog, schema and type
arguments. However, you should be aware that if the statement
attribute \s-1SQL_ATTR_METADATA_ID\s0 is \s-1SQL_TRUE\s0 the values are interpreted
as identifiers and the case is ignored. \s-1SQL_ATTR_METADATA_ID\s0 defaults
to \s-1SQL_FALSE\s0 so normally the values are treated as patterns and the
case is significant.
.PP
SQLGetInfo for \s-1SQL_ACCESSIBLE_TABLES\s0 can affect what tables you can
list.
.PP
All the special cases listed by \s-1DBI\s0 (empty strings for all arguments
but one which is '%') for catalog, schema and table type are supported
by \s-1DBD::ODBC.\s0 However, using '%' for table type in a call to the
tables method does not currently work with \s-1DBI\s0 up to 1.631 due to an
issue in \s-1DBI.\s0
.PP
Although \s-1DBD::ODBC\s0 supports all the usage cases listed by \s-1DBI,\s0 your
\&\s-1ODBC\s0 driver may not.
.SS "Unicode"
.IX Subsection "Unicode"
The \s-1ODBC\s0 specification supports wide character versions (a postfix of
\&'W') of some of the normal \s-1ODBC\s0 APIs e.g., SQLDriverConnectW is a wide
character version of SQLDriverConnect.
.PP
In \s-1ODBC\s0 on Windows the wide characters are defined as SQLWCHARs (2
bytes) and are \s-1UCS\-2\s0 (but \s-1UTF\-16\s0 is accepted by some drivers now e.g.,
\&\s-1MS SQL\s0 Server 2012 and the new collation suffix _SC which stands for
Supplementary Character Support). On non-Windows, the main driver
managers I know of have implemented the wide character APIs
differently:
.IP "unixODBC" 4
.IX Item "unixODBC"
unixODBC mimics the Windows \s-1ODBC API\s0 precisely meaning the wide
character versions expect and return 2\-byte characters in
\&\s-1UCS\-2\s0 or \s-1UTF\-16.\s0
.Sp
unixODBC will happily recognise \s-1ODBC\s0 drivers which only have the \s-1ANSI\s0
versions of the \s-1ODBC API\s0 and those that have the wide versions
too.
.Sp
unixODBC will allow an \s-1ANSI\s0 application to work with a unicode
\&\s-1ODBC\s0 driver and vice versa (although in the latter case you obviously
cannot actually use unicode).
.Sp
unixODBC does not prevent you sending \s-1UTF\-8\s0 in the \s-1ANSI\s0 versions of
the \s-1ODBC\s0 APIs but whether that is understood by your \s-1ODBC\s0 driver is
another matter.
.Sp
unixODBC differs in only one way from the Microsoft \s-1ODBC\s0 driver in
terms of unicode support in that it avoids unnecessary translations
between single byte and double byte characters when an \s-1ANSI\s0
application is using a unicode-aware \s-1ODBC\s0 driver by requiring unicode
applications to signal their intent by calling SQLDriverConnectW
first. On Windows, the \s-1ODBC\s0 driver manager always uses the wide
versions of the \s-1ODBC API\s0 in \s-1ODBC\s0 drivers which provide the wide
versions regardless of what the application really needs and this
results in a lot of unnecessary character translations when you have
an \s-1ANSI\s0 application and a unicode \s-1ODBC\s0 driver.
.IP "iODBC" 4
.IX Item "iODBC"
The wide character versions expect and return wchar_t types.
.PP
\&\s-1DBD::ODBC\s0 has gone with unixODBC so you cannot use iODBC with a
unicode build of \s-1DBD::ODBC.\s0 However, some \s-1ODBC\s0 drivers support \s-1UTF\-8\s0
(although how they do this with SQLGetData reliably I don't know)
and so you should be able to use those with \s-1DBD::ODBC\s0 not built for
unicode.
.PP
\fIEnabling and Disabling Unicode support\fR
.IX Subsection "Enabling and Disabling Unicode support"
.PP
On Windows Unicode support is enabled by default and to disable it
you will need to specify \f(CW\*(C`\-nou\*(C'\fR to \fIMakefile.PL\fR to get back to the
original behavior of \s-1DBD::ODBC\s0 before any Unicode support was added.
.PP
e.g.,
.PP
.Vb 1
\&  perl Makfile.PL \-nou
.Ve
.PP
On non-Windows platforms Unicode support is disabled by default. To
enable it specify \f(CW\*(C`\-u\*(C'\fR to \fIMakefile.PL\fR when you configure \s-1DBD::ODBC.\s0
.PP
e.g.,
.PP
.Vb 1
\&  perl Makefile.PL \-u
.Ve
.PP
\fIUnicode \- What is supported?\fR
.IX Subsection "Unicode - What is supported?"
.PP
As of version 1.17 \s-1DBD::ODBC\s0 has the following unicode support:
.IP "\s-1SQL\s0 (introduced in 1.16_2)" 4
.IX Item "SQL (introduced in 1.16_2)"
Unicode strings in calls to the \f(CW\*(C`prepare\*(C'\fR and \f(CW\*(C`do\*(C'\fR methods are
supported so long as the \f(CW\*(C`odbc_execdirect\*(C'\fR attribute is not used.
.IP "unicode connection strings (introduced in 1.16_2)" 4
.IX Item "unicode connection strings (introduced in 1.16_2)"
Unicode connection strings are supported but you will need a \s-1DBI\s0
post 1.607 for that.
.IP "column names" 4
.IX Item "column names"
Unicode column names are returned.
.IP "bound columns (introduced in 1.15)" 4
.IX Item "bound columns (introduced in 1.15)"
If the \s-1DBMS\s0 reports the column as being a wide character (SQL_Wxxx) it
will be bound as a wide character and any returned data will be
converted from \s-1UTF\-16\s0 to \s-1UTF\-8\s0 and the \s-1UTF\-8\s0 flag will then be set on
the data.
.IP "bound parameters" 4
.IX Item "bound parameters"
If the perl scalars you bind to parameters are marked \s-1UTF\-8\s0 and the
\&\s-1DBMS\s0 reports the type as being a wide type or you bind the parameter
as a wide type they will be converted to wide characters and bound as
such.
.IP "metadata calls like table_info, column_info" 4
.IX Item "metadata calls like table_info, column_info"
As of \s-1DBD::ODBC 1.32_3\s0 meta data calls accept Unicode strings.
.PP
Since version 1.16_4, the default parameter bind type is \s-1SQL_WVARCHAR\s0
for unicode builds of \s-1DBD::ODBC.\s0 This only affects \s-1ODBC\s0 drivers which
do not support SQLDescribeParam and only then if you do not
specifically set a \s-1SQL\s0 type on the bind_param method call.
.PP
The above Unicode support has been tested with the \s-1SQL\s0 Server, Oracle
9.2+ and Postgres drivers on Windows and various Easysoft \s-1ODBC\s0 drivers
on \s-1UNIX.\s0
.PP
\fIUnicode \- What is not supported?\fR
.IX Subsection "Unicode - What is not supported?"
.PP
You cannot use unicode parameter names e.g.,
.PP
.Vb 1
\&  select * from table where column = :unicode_param_name
.Ve
.PP
You cannot use unicode strings in calls to prepare if you set the
odbc_execdirect attribute.
.PP
You cannot use the iODBC driver manager with \s-1DBD::ODBC\s0 built for
unicode.
.PP
\fIUnicode \- Caveats\fR
.IX Subsection "Unicode - Caveats"
.PP
For Unicode support on any platform in Perl you will need at least
Perl 5.8.1 \- sorry but this is the way it is with Perl.
.PP
The Unicode support in \s-1DBD::ODBC\s0 expects a \s-1WCHAR\s0 to be 2 bytes (as it
is on Windows and as the \s-1ODBC\s0 specification suggests it is). Until
\&\s-1ODBC\s0 specifies any other Unicode support it is not envisioned this
will change.  On \s-1UNIX\s0 there are a few different \s-1ODBC\s0 driver
managers. I have only tested the unixODBC driver manager
(http://www.unixodbc.org) with Unicode support and it was built with
defaults which set \s-1WCHAR\s0 as 2 bytes.
.PP
I believe that the iODBC driver manager expects wide characters to be
wchar_t types (which are usually 4 bytes) and hence \s-1DBD::ODBC\s0 will not
work iODBC when built for unicode.
.PP
The \s-1ODBC\s0 Driver must expect Unicode data specified in SQLBindParameter
and SQLBindCol to be \s-1UTF\-16\s0 in local endianness. Similarly, in calls to
SQLPrepareW, SQLDescribeColW and SQLDriverConnectW.
.PP
You should be aware that once Unicode support is enabled it affects a
number of \s-1DBI\s0 methods (some of which you might not expect). For
instance, when listing tables, columns etc some drivers
(e.g. Microsoft \s-1SQL\s0 Server) will report the column types as wide types
even if the strings actually fit in 7\-bit \s-1ASCII.\s0 As a result, there is
an overhead for retrieving this column data as 2 bytes per character
will be transmitted (compared with 1 when Unicode support is not
enabled) and these strings will be converted into \s-1UTF\-8\s0 but will end up
fitting (in most cases) into 7bit \s-1ASCII\s0 so a lot of conversion work
has been performed for nothing. If you don't have Unicode table and
column names or Unicode column data in your tables you are best
disabling Unicode support.
.PP
I am at present unsure if ChopBlanks processing on Unicode strings is
working correctly on \s-1UNIX.\s0 If nothing else the construct L' ' in
dbdimp.c might not work with all \s-1UNIX\s0 compilers. Reports of issues and
patches welcome.
.PP
\fIUnicode implementation in \s-1DBD::ODBC\s0\fR
.IX Subsection "Unicode implementation in DBD::ODBC"
.PP
\&\s-1DBD::ODBC\s0 uses the wide character versions of the \s-1ODBC API\s0 and the
\&\s-1SQL_WCHAR ODBC\s0 type to support unicode in Perl.
.PP
Wide characters returned from the \s-1ODBC\s0 driver will be converted to
\&\s-1UTF\-8\s0 and the perl scalars will have the utf8 flag set (by using
sv_utf8_decode).
.PP
\&\fB\s-1IMPORTANT\s0\fR
.PP
Perl scalars which are \s-1UTF\-8\s0 and are sent through the \s-1ODBC API\s0 will be
converted to \s-1UTF\-16\s0 and passed to the \s-1ODBC\s0 wide APIs or signalled as
SQL_WCHARs (e.g., in the case of bound columns). Retrieved data which
are wide characters are converted from \s-1UTF\-16\s0 to \s-1UTF\-8.\s0 However, you
should realise most \s-1ODBC\s0 drivers do not support \s-1UTF\-16, ODBC\s0 only
talks about wide characters being 2 bytes and \s-1UCS\-2\s0 and \s-1UCS\-2\s0 and
\&\s-1UTF\-16\s0 are not the same. \s-1UCS\-2\s0 only supports Unicode characters in the
first plane (the Basic Multilangual Plane or \s-1BMP\s0) (code points U+0000
to U+FFFF), the most frequently used characters. So why does \s-1DBD::ODBC\s0
currently encode in \s-1UTF\-16\s0? For around 97% of Unicode characters in
the range 0\-0xFFFF \s-1UCS\-2\s0 and \s-1UTF\-16\s0 are exactly the same (and where they
differ there is no valid Unicode character as the range U+D800 to U+DFFF is
reserved from use only as surrogate pairs). As the \s-1ODBC
API\s0 currently uses \s-1UCS\-2\s0 it does not support Unicode characters with
code points above 0xFFFF (if you know better I'd like to hear from
you). However, because \s-1DBD::ODBC\s0 uses \s-1UTF\-16\s0 encoding you can still
insert Unicode characters above 0xFFFF into your database and retrieve
them back correctly but they may not being treated as a single
Unicode character in your database e.g., a \*(L"select length(a_column)
from table\*(R" with a single Unicode character above 0xFFFF may
return 2 and not 1 so you cannot use database functions on that
data like upper/lower/length etc but you can at least save the data in
your database and get it back.
.PP
When built for unicode, \s-1DBD::ODBC\s0 will always call SQLDriverConnectW
(and not SQLDriverConnect) even if a) your connection string is not
unicode b) you have not got a \s-1DBI\s0 later than 1.607, because unixODBC
requires SQLDriverConnectW to be called if you want to call other
unicode \s-1ODBC\s0 APIs later. As a result, if you build for unicode and
pass \s-1ASCII\s0 strings to the connect method they will be converted to
\&\s-1UTF\-16\s0 and passed to SQLDriverConnectW. This should make no real
difference to perl not using unicode connection strings.
.PP
You will need a \s-1DBI\s0 later than 1.607 to support unicode connection
strings because until post 1.607 there was no way for \s-1DBI\s0 to pass
unicode strings to the \s-1DBD.\s0
.PP
\fIUnicode and Oracle\fR
.IX Subsection "Unicode and Oracle"
.PP
You have to set the environment variables \f(CW\*(C`NLS_NCHAR=AL32UTF8\*(C'\fR and
\&\f(CW\*(C`NLS_LANG=AMERICAN_AMERICA.AL32UTF8\*(C'\fR (or any other language setting
ending with \f(CW\*(C`.AL32UTF8\*(C'\fR) before loading \s-1DBD::ODBC\s0 to make Oracle
return Unicode data. (See also \*(L"Oracle and Unicode\*(R" in the \s-1POD\s0 of
DBD::Oracle.)
.PP
On Windows, using the Oracle \s-1ODBC\s0 Driver you have to enable the \fBForce
\&\s-1SQL_WCHAR\s0 support\fR Workaround in the data source configuration to make
Oracle return Unicode to a non-Unicode application. Alternatively, you
can include \f(CW\*(C`FWC=T\*(C'\fR in your connect string.
.PP
Unless you need to use \s-1ODBC,\s0 if you want Unicode support with Oracle
you are better off using DBD::Oracle.
.PP
\fIUnicode and PostgreSQL\fR
.IX Subsection "Unicode and PostgreSQL"
.PP
See the odbc_utf8_on parameter to treat all strings as utf8.
.PP
Some tests from the original \s-1DBD::ODBC 1.13\s0 fail with PostgreSQL
8.0.3, so you may not want to use \s-1DBD::ODBC\s0 to connect to PostgreSQL
8.0.3.
.PP
Unicode tests fail because PostgreSQL seems not to give any hints
about Unicode, so all data is treated as non-Unicode.
.PP
Unless you need to use \s-1ODBC,\s0 if you want Unicode support with Postgres
you are better off with DBD::Pg as it has a specific attribute named
\&\f(CW\*(C`pg_enable_utf8\*(C'\fR to enable Unicode support.
.PP
\fIUnicode and Easysoft \s-1ODBC\s0 Drivers\fR
.IX Subsection "Unicode and Easysoft ODBC Drivers"
.PP
We have tested the Easysoft \s-1SQL\s0 Server, Oracle and \s-1ODBC\s0 Bridge drivers
with \s-1DBD::ODBC\s0 built for Unicode. All work as described without
modification except for the Oracle driver you will need to set you
\&\s-1NLS_LANG\s0 as mentioned above.
.PP
\fIUnicode and other \s-1ODBC\s0 drivers\fR
.IX Subsection "Unicode and other ODBC drivers"
.PP
If you have a unicode-enabled \s-1ODBC\s0 driver and it works with \s-1DBD::ODBC\s0
let me know and I will include it here.
.SS "\s-1ODBC\s0 Support in \s-1ODBC\s0 Drivers"
.IX Subsection "ODBC Support in ODBC Drivers"
\fIDrivers without SQLDescribeParam\fR
.IX Subsection "Drivers without SQLDescribeParam"
.PP
Some drivers do not support the \f(CW\*(C`SQLDescribeParam\*(C'\fR \s-1ODBC API\s0 (e.g.,
Microsoft Access, FreeTDS).
.PP
\&\s-1DBD::ODBC\s0 uses the \f(CW\*(C`SQLDescribeParam\*(C'\fR \s-1API\s0 when parameters are bound
to your \s-1SQL\s0 to find the types of the parameters. If the \s-1ODBC\s0 driver
does not support \f(CW\*(C`SQLDescribeParam\*(C'\fR, \s-1DBD::ODBC\s0 assumes the parameters
are \f(CW\*(C`SQL_VARCHAR\*(C'\fR or \f(CW\*(C`SQL_WVARCHAR\*(C'\fR types (depending on whether
\&\s-1DBD::ODBC\s0 is built for unicode or not and whether your parameter is
unicode data). In any case, if you bind a parameter and specify a \s-1SQL\s0
type this overrides any type \s-1DBD::ODBC\s0 would choose.
.PP
For \s-1ODBC\s0 drivers which do not support \f(CW\*(C`SQLDescribeParam\*(C'\fR the default
behavior in \s-1DBD::ODBC\s0 may not be what you want. To change the default
parameter bind type set \*(L"odbc_default_bind_type\*(R". If, after that you
have some \s-1SQL\s0 where you need to vary the parameter types used add the
\&\s-1SQL\s0 type to the end of the \f(CW\*(C`bind_param\*(C'\fR method.
.PP
.Vb 7
\&  use DBI qw(:sql_types);
\&  $h = DBI\->connect;
\&  # set the default bound parameter type
\&  $h\->{odbc_default_bind_type} = SQL_VARCHAR;
\&  # bind a parameter with a specific type
\&  $s = $h\->prepare(q/insert into mytable values(?)/);
\&  $s\->bind_param(1, "\ex{263a}", SQL_WVARCHAR);
.Ve
.SS "\s-1MS SQL\s0 Server Query Notification"
.IX Subsection "MS SQL Server Query Notification"
Query notifications were introduced in \s-1SQL\s0 Server 2005 and \s-1SQL\s0 Server
Native Client.  Query notifications allow applications to be notified
when data has changed.
.PP
\&\s-1DBD::ODBC\s0 supports query notification with \s-1MS SQL\s0 Server using the additional
prepare attributes odbc_qn_msgtxt, odbc_qn_options and odbc_qn_timeout. When
you pass suitable values for these attributes to the prepare method, \s-1DBD::ODBC\s0
will make the appropriate SQLSetStmtAttr calls after the statement
has been allocated.
.PP
It is beyond the scope of this document to provide a tutorial on doing this
but here are some notes that might help you get started.
.PP
On \s-1SQL\s0 Server
.PP
.Vb 10
\&  create database MyDatabase
\&  ALTER DATABASE MyDatabase SET ENABLE_BROKER
\&  use MyDatabase
\&  CREATE TABLE QNtest (a int NOT NULL PRIMARY KEY,
\&                       b nchar(5) NOT NULL,
\&                       c datetime NOT NULL)
\&  INSERT QNtest (a, b, c) SELECT 1, \*(AqALFKI\*(Aq, \*(Aq19991212\*(Aq
\&  CREATE QUEUE myQueue
\&  CREATE SERVICE myService ON QUEUE myQueue
\&  See L<http://technet.microsoft.com/en\-us/library/ms175110%28v=SQL.105%29.aspx>
.Ve
.PP
You need to set these \s-1SQL\s0 Server permissions unless the subscriber is a sysadmin:
.PP
.Vb 2
\&  GRANT RECEIVE ON QueryNotificationErrorsQueue TO "<login\-for\-subscriber>"
\&  GRANT SUBSCRIBE QUERY NOTIFICATIONS TO "<login\-for\-subscriber>"
.Ve
.PP
To subscribe to query notification for this example:
.PP
.Vb 11
\&  # Prepare the statement.
\&  # This is the SQL you want to know if the result changes later
\&  my $sth = $dbh\->prepare(q/SELECT a, b, c FROM dbo.QNtest WHERE a = 1/,
\&                          {odbc_qn_msgtxt => \*(AqMessage text\*(Aq,
\&                           odbc_qn_options => \*(Aqservice=myService\*(Aq,
\&                           odbc_qn_timeout=> 430000});
\&  # Fetch and display the result set value.
\&  while ( my @row = $sth\->fetchrow_array ) {
\&     print "@row\en";
\&  }
\&  # select * from sys.dm_qn_subscriptions will return a record now you are subscribed
.Ve
.PP
To wait for notification:
.PP
.Vb 3
\&  # Avoid "String data, right truncation" error when retrieving
\&  # the message.
\&  $dbh\->{LongReadLen} = 800;
\&
\&  # This query generates a result telling you which query has changed
\&  # It will block until the timeout or the query changes
\&  my $sth = $dbh\->prepare(q/WAITFOR (RECEIVE * FROM MyQueue)/);
\&  $sth\->execute();
\&
\&  # in the mean time someone does UPDATE dbo.QNtest SET c = \*(Aq19981212\*(Aq WHERE a = 1
\&
\&  # Fetch and display the result set value.
\&  while ( my @row = $sth\->fetchrow_array ) {
\&     print "@row\en";
\&  }
\&  # You now need to understand the result and look to decide which query has changed
.Ve
.SS "Version Control"
.IX Subsection "Version Control"
\&\s-1DBD::ODBC\s0 source code was under version control at svn.perl.org
until April 2013 when svn.perl.org was closed down and it is now on
github at https://github.com/perl5\-dbi/DBD\-ODBC.git.
.SS "Contributing"
.IX Subsection "Contributing"
There are a number of ways you may help with the development and
maintenance of this module:
.IP "Submitting patches" 4
.IX Item "Submitting patches"
Please send me a git pull request or email a unified diff.
.Sp
Please try and include a test which demonstrates the fix/change
working.
.IP "Reporting installs" 4
.IX Item "Reporting installs"
Install CPAN::Reporter and report you installations. This is easy to
do \- see \*(L"\s-1CPAN\s0 Testers Reporting\*(R".
.IP "Report bugs" 4
.IX Item "Report bugs"
If you find what you believe is a bug then enter it into the
<http://rt.cpan.org/Dist/Display.html?Name=DBD\-ODBC> system. Where
possible include code which reproduces the problem including any
schema required and the versions of software you are using.
.Sp
If you are unsure whether you have found a bug report it anyway or
post it to the dbi-users mailing list.
.IP "pod comments and corrections" 4
.IX Item "pod comments and corrections"
If you find inaccuracies in the \s-1DBD::ODBC\s0 pod or have a comment which
you think should be added then go to <http://annocpan.org> and submit
them there. I get an email for every comment added and will review
each one and apply any changes to the documentation.
.IP "Review \s-1DBD::ODBC\s0" 4
.IX Item "Review DBD::ODBC"
Add your review of \s-1DBD::ODBC\s0 on <http://cpanratings.perl.org>.
.Sp
If you are a member on ohloh then add your review or register your
use of \s-1DBD::ODBC\s0 at <http://www.ohloh.net/projects/perl_dbd_odbc>.
.IP "submit test cases" 4
.IX Item "submit test cases"
Most DBDs are built against a single client library for the database.
.Sp
Unlike other DBDs, \s-1DBD::ODBC\s0 works with many different \s-1ODBC\s0 drivers.
Although they all should be written with regard to the \s-1ODBC\s0
specification drivers have bugs and in some places the specification is
open to interpretation. As a result, when changes are applied to
\&\s-1DBD::ODBC\s0 it is very easy to break something in one \s-1ODBC\s0 driver.
.Sp
What helps enormously to identify problems in the many combinations
of \s-1DBD::ODBC\s0 and \s-1ODBC\s0 drivers is a large test suite. I would greatly
appreciate any test cases and in particular any new test cases for
databases other than \s-1MS SQL\s0 Server.
.IP "Test \s-1DBD::ODBC\s0" 4
.IX Item "Test DBD::ODBC"
I have a lot of problems deciding when to move a development release
to an official release since I get few test reports for development
releases. What often happens is I call for testers on various lists,
get a few and then get inundated with requests to do an official
release. Then I do an official release and loads of rts appear out of
nowhere and the cycle starts again.
.Sp
\&\s-1DBD::ODBC\s0 by its very nature works with many \s-1ODBC\s0 Drivers and it is
impossible for me to have and test them all (this differs from other
DBDs). If you depend on \s-1DBD::ODBC\s0 you should be interested in new
releases and if you send me your email address suggesting you are
prepared to be part of the \s-1DBD::ODBC\s0 testing network I will credit you
in the Changes file and perhaps the main \s-1DBD::ODBC\s0 file.
.SS "\s-1CPAN\s0 Testers Reporting"
.IX Subsection "CPAN Testers Reporting"
Please, please, please (is that enough), consider installing
CPAN::Reporter so that when you install perl modules a report of the
installation success or failure can be sent to cpan testers. In this
way module authors 1) get feedback on the fact that a module is being
installed 2) get to know if there are any installation problems. Also
other people like you may look at the test reports to see how
successful they are before choosing the version of a module to
install.
.PP
See this guide on how to get started with sending test reports:
<http://wiki.cpantesters.org/wiki/QuickStart>.
.SS "Others/todo?"
.IX Subsection "Others/todo?"
Level 2
.PP
.Vb 6
\&    SQLColumnPrivileges
\&    SQLProcedureColumns
\&    SQLProcedures
\&    SQLTablePrivileges
\&    SQLDrivers
\&    SQLNativeSql
.Ve
.SS "Random Links"
.IX Subsection "Random Links"
These are in need of sorting and annotating. Some are relevant only
to \s-1ODBC\s0 developers.
.PP
You can find \s-1DBD::ODBC\s0 on ohloh now at:
.PP
<http://www.ohloh.net/projects/perl_dbd_odbc>
.PP
If you use ohloh and \s-1DBD::ODBC\s0 please say you use it and rate it.
.PP
There is a good search engine for the various Perl \s-1DBI\s0 lists at the
following \s-1URLS:\s0
.PP
<http://perl.markmail.org/search/list:org.perl.dbi\-users>
.PP
<http://perl.markmail.org/search/list:org.perl.dbi\-dev>
.PP
<http://perl.markmail.org/search/list:org.perl.dbi\-announce>
.PP
<http://www.syware.com>
.PP
<http://www.microsoft.com/odbc>
.PP
For Linux/Unix folks, compatible \s-1ODBC\s0 driver managers can be found at:
.PP
<http://www.unixodbc.org> (unixODBC source and rpms)
.PP
<http://www.iodbc.org> (iODBC driver manager source)
.PP
For Linux/Unix folks, you can checkout the following for \s-1ODBC\s0 Drivers and
Bridges:
.PP
<http://www.easysoft.com>
.PP
<http://www.openlinksw.com>
.PP
<http://www.datadirect.com>
.PP
<http://www.atinet.com>
.SS "Some useful tutorials:"
.IX Subsection "Some useful tutorials:"
Debugging Perl \s-1DBI:\s0
.PP
<http://www.easysoft.com/developer/languages/perl/dbi\-debugging.html>
.PP
Enabling \s-1ODBC\s0 support in Perl with Perl \s-1DBI\s0 and \s-1DBD::ODBC:\s0
.PP
<http://www.easysoft.com/developer/languages/perl/dbi_dbd_odbc.html>
.PP
Perl \s-1DBI/DBD::ODBC\s0 Tutorial Part 1 \- Drivers, Data Sources and Connection:
.PP
<http://www.easysoft.com/developer/languages/perl/dbd_odbc_tutorial_part_1.html>
.PP
Perl \s-1DBI/DBD::ODBC\s0 Tutorial Part 2 \- Introduction to retrieving data from your database:
.PP
<http://www.easysoft.com/developer/languages/perl/dbd_odbc_tutorial_part_2.html>
.PP
Perl \s-1DBI/DBD::ODBC\s0 Tutorial Part 3 \- Connecting Perl on \s-1UNIX\s0 or Linux to Microsoft \s-1SQL\s0 Server:
.PP
<http://www.easysoft.com/developer/languages/perl/sql_server_unix_tutorial.html>
.PP
Perl \s-1DBI\s0 \- Put Your Data On The Web:
.PP
<http://www.easysoft.com/developer/languages/perl/tutorial_data_web.html>
.PP
Multiple Active Statements (\s-1MAS\s0) and \s-1DBD::ODBC\s0
.PP
<http://www.easysoft.com/developer/languages/perl/multiple\-active\-statements.html>
.PP
64\-bit \s-1ODBC\s0
.PP
<http://www.easysoft.com/developer/interfaces/odbc/64\-bit.html>
.PP
How do I insert Unicode supplementary characters into \s-1SQL\s0 Server from Perl?
.PP
<http://www.easysoft.com/support/kb/kb01043.html>
.PP
Some Common Unicode Problems and Solutions using Perl \s-1DBD::ODBC\s0 and \s-1MS SQL\s0 Server
.PP
<http://www.easysoft.com/developer/languages/perl/sql\-server\-unicode.html>
.PP
and a version possibly kept more up to date:
.PP
<https://github.com/mjegh/dbd_odbc_sql_server_unicode/blob/master/common_problems.pod>
.PP
How do I use \s-1SQL\s0 Server Query Notifications from Linux and \s-1UNIX\s0?
.PP
<http://www.easysoft.com/support/kb/kb01069.html>
.SS "Frequently Asked Questions"
.IX Subsection "Frequently Asked Questions"
Frequently asked questions are now in \s-1DBD::ODBC::FAQ\s0. Run
\&\f(CW\*(C`perldoc DBD::ODBC::FAQ\*(C'\fR to view them.
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
You should consult the documentation for the \s-1ODBC\s0 Driver Manager
you are using.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
\&\s-1DBI\s0
.PP
Test::Simple
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None known.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
None known other than the deviations from the \s-1DBI\s0 specification mentioned
above in \*(L"Deviations from the \s-1DBI\s0 specification\*(R".
.PP
Please report any to me via the \s-1CPAN RT\s0 system. See
<http://rt.cpan.org/> for more details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tim Bunce
.PP
Jeff Urlwin
.PP
Thomas K. Wenrich
.PP
Martin J. Evans
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. See perlartistic. This
program is distributed in the hope that it will be useful, but \s-1WITHOUT
ANY WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or
\&\s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
Portions of this software are Copyright Tim Bunce, Thomas K. Wenrich,
Jeff Urlwin and Martin J. Evans \- see the source.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0
.PP
\&\s-1DBD::ODBC\s0 can be used with many \s-1ODBC\s0 drivers to many different
databases.  If you want a generic \s-1DBD\s0 for multiple databases \s-1DBD::ODBC\s0
is probably for you.  If you are only accessing a single database then
you might want to look for DBD::my_database (e.g. DBD::Oracle) as
database specific DBDs often have more functionality.
.PP
DBIx::LogAny or DBIx::Log4perl for logging \s-1DBI\s0 method calls, \s-1SQL,\s0
parameters and results.
