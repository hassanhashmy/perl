.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DateTime::Format::Duration 3"
.TH DateTime::Format::Duration 3 "2015-09-20" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DateTime::Format::Duration \- Format and parse DateTime::Durations
.SH "VERSION"
.IX Header "VERSION"
version 1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use DateTime::Format::Duration;
\&
\&    $d = DateTime::Format::Duration\->new(
\&        pattern => \*(Aq%Y years, %m months, %e days, \*(Aq.
\&                \*(Aq%H hours, %M minutes, %S seconds\*(Aq
\&    );
\&
\&    print $d\->format_duration(
\&        DateTime::Duration\->new(
\&            years   => 3,
\&            months  => 5,
\&            days    => 1,
\&            hours   => 6,
\&            minutes => 15,
\&            seconds => 45,
\&            nanoseconds => 12000
\&        )
\&    );
\&    # 3 years, 5 months, 1 days, 6 hours, 15 minutes, 45 seconds
\&
\&
\&    $duration = $d\->parse_duration(
\&        \*(Aq3 years, 5 months, 1 days, 6 hours, 15 minutes, 45 seconds\*(Aq
\&    );
\&    # Returns DateTime::Duration object
\&
\&
\&    print $d\->format_duration_from_deltas(
\&        years   => 3,
\&        months  => 5,
\&        days    => 1,
\&        hours   => 6,
\&        minutes => 15,
\&        seconds => 45,
\&        nanoseconds => 12000
\&    );
\&    # 3 years, 5 months, 1 days, 6 hours, 15 minutes, 45 seconds
\&
\&    %deltas = $d\->parse_duration_as_deltas(
\&          \*(Aq3 years, 5 months, 1 days, 6 hours, 15 minutes, 45 seconds\*(Aq
\&    );
\&    # Returns hash:
\&    # (years=>3, months=>5, days=>1, hours=>6, minutes=>15, seconds=>45)
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
This module formats and parses DateTime::Duration objects
as well as other durations representations.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
This module contains a single constructor:
.IP "\(bu" 4
\&\f(CW\*(C`new( ... )\*(C'\fR
.Sp
The \f(CW\*(C`new\*(C'\fR constructor takes the following attributes:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`pattern => $string\*(C'\fR
.Sp
This is a strf type pattern detailing the format of the duration.
See the \*(L"Patterns\*(R" sections below for more information.
.IP "\(bu" 4
\&\f(CW\*(C`normalise => $one_or_zero_or_ISO\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`normalize => $one_or_zero_or_ISO\*(C'\fR
.Sp
This determines whether durations are 'normalised'. For example, does
120 seconds become 2 minutes?
.Sp
Setting this value to true without also setting a \f(CW\*(C`base\*(C'\fR means we will
normalise without a base. See the \*(L"Normalising without a base\*(R" section
below.
.IP "\(bu" 4
\&\f(CW\*(C`base => $datetime_object\*(C'\fR
.Sp
If a base DateTime is given then that is the normalisation date. Setting
this attribute overrides the above option and sets normalise to true.
.RE
.RS 4
.RE
.SH "METHODS"
.IX Header "METHODS"
DateTime::Format::Duration has the following methods:
.IP "\(bu" 4
\&\f(CW\*(C`format_duration( $datetime_duration_object )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`format_duration( duration => $dt_duration, pattern => $pattern )\*(C'\fR
.Sp
Returns a string representing a DateTime::Duration object in the format set
by the pattern. If the first form is used, the pattern is taken from the
object. If the object has no pattern then this method will croak.
.IP "\(bu" 4
\&\f(CW\*(C`format_duration_from_deltas( %deltas )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`format_duration_from_deltas( %deltas, pattern => $pattern )\*(C'\fR
.Sp
As above, this method returns a string representing a duration in the format
set by the pattern. However this method takes a hash of values. Permissible
hash keys are \f(CW\*(C`years, months, days, hours, minutes, seconds\*(C'\fR and \f(CW\*(C`nanoseconds\*(C'\fR
as well as \f(CW\*(C`negative\*(C'\fR which, if true, inverses the duration. (\f(CW\*(C`years => \-1\*(C'\fR is
the same as \f(CW\*(C`years => 1, negative=>1\*(C'\fR)
.IP "\(bu" 4
\&\f(CW\*(C`parse_duration( $string )\*(C'\fR
.Sp
This method takes a string and returns a DateTime::Duration object that is the
equivalent according to the pattern.
.IP "\(bu" 4
\&\f(CW\*(C`parse_duration_as_deltas( $string )\*(C'\fR
.Sp
Once again, this method is the same as above, however it returns a hash rather
than an object.
.IP "\(bu" 4
\&\f(CW\*(C`normalise( $duration_object )\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`normalize( %deltas )\*(C'\fR
.Sp
Returns a hash of deltas after normalising the input. See the \*(L"\s-1NORMALISE\*(R"\s0
section below for more information.
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.IP "\(bu" 4
\&\f(CW\*(C`pattern()\*(C'\fR
.Sp
Returns the current pattern.
.IP "\(bu" 4
\&\f(CW\*(C`base()\*(C'\fR
.Sp
Returns the current base.
.IP "\(bu" 4
\&\f(CW\*(C`normalising()\*(C'\fR
.Sp
Indicates whether or not the durations are being normalised.
.SH "SETTERS"
.IX Header "SETTERS"
All setters return the object so that they can be strung together.
.IP "\(bu" 4
\&\f(CW\*(C`set_pattern( $new_pattern )\*(C'\fR
.Sp
Sets the pattern and returns the object.
.IP "\(bu" 4
\&\f(CW\*(C`set_base( $new_DateTime )\*(C'\fR
.Sp
Sets the base DateTime and returns the object.
.IP "\(bu" 4
\&\f(CW\*(C`set_normalising( $true_or_false_or_ISO )\*(C'\fR
.Sp
Turns normalising on or off and returns the object.
.SH "NOTES"
.IX Header "NOTES"
.SS "Patterns"
.IX Subsection "Patterns"
This module uses a similar set of patterns to strftime. These patterns
have been kept as close as possible to the original time-based patterns.
.IP "\(bu" 4
\&\f(CW%C\fR
.Sp
The number of hundreds of years in the duration. 400 years would return 4.
This is similar to centuries.
.IP "\(bu" 4
\&\f(CW%d\fR
.Sp
The number of days zero-padded to two digits. 2 days returns 02. 22 days
returns 22 and 220 days returns 220.
.IP "\(bu" 4
\&\f(CW%e\fR
.Sp
The number of days.
.IP "\(bu" 4
\&\f(CW%F\fR
.Sp
Equivalent of \f(CW%Y\fR\-%m\-%d
.IP "\(bu" 4
\&\f(CW%H\fR
.Sp
The number of hours zero-padded to two digits.
.IP "\(bu" 4
\&\f(CW%I\fR
.Sp
Same as \f(CW%H\fR
.IP "\(bu" 4
\&\f(CW%j\fR
.Sp
The duration expressed in whole days. 36 hours returns 1
.IP "\(bu" 4
\&\f(CW%k\fR
.Sp
The hours without any padding
.IP "\(bu" 4
\&\f(CW%l\fR
.Sp
Same as \f(CW%k\fR
.IP "\(bu" 4
\&\f(CW%m\fR
.Sp
The months, zero-padded to two digits
.IP "\(bu" 4
\&\f(CW%M\fR
.Sp
The minutes, zero-padded to two digits
.IP "\(bu" 4
\&\f(CW%n\fR
.Sp
A linebreak when formatting and any whitespace when parsing
.IP "\(bu" 4
\&\f(CW%N\fR
.Sp
Nanoseconds \- see note on precision at end
.IP "\(bu" 4
\&\f(CW%p\fR
.Sp
Either a '+' or a '\-' indicating the positiveness of the duration
.IP "\(bu" 4
\&\f(CW%P\fR
.Sp
A '\-' for negative durations and nothing for positive durations.
.IP "\(bu" 4
\&\f(CW%r\fR
.Sp
Equivalent of \f(CW%H:\fR%M:%S
.IP "\(bu" 4
\&\f(CW%R\fR
.Sp
Equivalent of \f(CW%H:\fR%M
.IP "\(bu" 4
\&\f(CW%s\fR
.Sp
Returns the value as seconds. 1 day, 5 seconds return 86405
.IP "\(bu" 4
\&\f(CW%S\fR
.Sp
Returns the seconds, zero-padded to two digits
.IP "\(bu" 4
\&\f(CW%t\fR
.Sp
A tab character when formatting or any whitespace when parsing
.IP "\(bu" 4
\&\f(CW%T\fR
.Sp
Equivalent of \f(CW%P\fR%H:%M:%S
.IP "\(bu" 4
\&\f(CW%u\fR
.Sp
Days after weeks are removed. 4 days returns 4, but 22 days returns 1
(22 days is three weeks, 1 day)
.IP "\(bu" 4
\&\f(CW%V\fR
.Sp
Duration expressed as weeks. 355 days returns 52.
.IP "\(bu" 4
\&\f(CW%W\fR
.Sp
Duration expressed as floating weeks. 10 days, 12 hours returns 1.5 weeks.
.IP "\(bu" 4
\&\f(CW%y\fR
.Sp
Years in the century. 145 years returns 45.
.IP "\(bu" 4
\&\f(CW%Y\fR
.Sp
Years, zero-padded to four digits
.IP "\(bu" 4
%%
.Sp
A '%' symbol
.PP
\&\fBPrecision\fR can be changed for any and all the above values. For all but
nanoseconds (%N), the precision is the zero-padding. To change the precision
insert a number between the '%' and the letter. For example: 1 year formatted
with \f(CW%6Y\fR would return 000001 rather than the default 0001. Likewise, to remove
padding \f(CW%1Y\fR would just return a 1.
.PP
Nanosecond precision is the other way (nanoseconds are fractional and thus
should be right padded). 123456789 nanoseconds formatted with \f(CW%3N\fR would return
123 and formatted as \f(CW%12N\fR would return 123456789000.
.SS "Normalisation"
.IX Subsection "Normalisation"
This module contains a complex method for normalising durations. The method
ensures that the values for all components are as close to zero as possible.
Rather than returning 68 minutes, it is normalised to 1 hour, 8 minutes.
.PP
The complexity comes from three places:
.IP "\(bu" 4
Mixed positive and negative components
.Sp
The duration of 1 day, minus 2 hours is easy to normalise in your head to
22 hours. However consider something more complex such as \-2 years, +1 month,
+22 days, +11 hours, \-9 minutes.
.Sp
This module works from lowest to highest precision to calculate the duration.
So, based on a \f(CW\*(C`base\*(C'\fR of 2004\-03\-28T00:00:00 the following transformations take
place:
.Sp
.Vb 5
\&    2003\-01\-01T00:00:00 \- 2 years   = 2001\-01\-01T00:00:00 === \-2 years
\&    2001\-01\-01T00:00:00 + 1 month   = 2001\-02\-01T00:00:00 === \-1 year, 11 months
\&    2001\-02\-01T00:00:00 + 22 days   = 2001\-02\-23T00:00:00 === \-1yr, 10mths, 6days
\&    2001\-02\-22T00:00:00 + 11 hours  = 2001\-02\-23T11:00:00 === \-1y, 10m, 6d, 13h
\&    2001\-02\-22T11:00:00 \- 9 minutes = 2001\-02\-23T10:51:00 === \-1y, 10m, 6d, 13h, 9m
.Ve
See: https://raw.githubusercontent.com/karenetheridge/DateTime-Format-Duration/master/docs/figure1.gif
.Sp
Figure 1 illustrates that, with the given base, \-2 years, +1 month,
+22 days, +11 hours, \-9 minutes is normalised to \-1 year, 10 months, 6 days,
13 hours and 9 minutes.
.IP "\(bu" 4
Months of unequal length.
.Sp
Unfortunately months can have 28, 29, 30 or 31 days and it can change from year
to year. Thus if I wanted to normalise 2 months it could be any of 59 (Feb-Mar),
60 (Feb-Mar in a leap year), 61 (Mar-Apr, Apr-May, May-Jun, Jun-Jul, Aug-Sep,
Sep-Oct, Oct-Nov or Nov-Dec) or 62 days (Dec-Jan or Jul-Aug). Because of this
the module uses a base datetime for its calculations. If we use the base
2003\-01\-01T00:00:00 then two months would be 59 days (2003\-03\-01 \- 2003\-01\-01)
.IP "\(bu" 4
The order of components
.Sp
Components will always be assessed from lowest to highest precision (years, months,
days, hours, minutes, seconds, nanoseconds). This can really change things.
.Sp
Consider the duration of 1 day, 24 hours. Normally this will normalise to 2 days.
However, consider changes to Daylight Savings. On the changes to and from \s-1DST\s0
days have 25 and 23 hours.
.Sp
If we take the base DateTime as midnight on the day \s-1DST\s0 ends (when there's 25
hours in the day), and add 1 day, 24 hours we end up at midnight 2 days later.
So our duration normalises to two days.
.Sp
However, if we add 24 hours, 1 day we end up at 11pm on the next day! Why is this?
Because midnight + 24 hours = 11pm (there's 25 hours on this day!), then we add 1
day and end up at 11pm on the following day.
See: https://raw.githubusercontent.com/karenetheridge/DateTime-Format-Duration/master/docs/figure2.gif
.Sp
Figure 2 illustrates the above problem on timelines.
.IP "\(bu" 4
Leap years and leap seconds
.Sp
Leap years and seconds further add to the confusion in normalisation. Leap
seconds mean there are minutes that are 61 seconds long, thus 130 seconds can
be 2 minutes, 10 seconds or 2 minutes 9 seconds, depending on the base DateTime.
Similarly leap years mean a day can have 23, 24 or 25 hours.
See: https://raw.githubusercontent.com/karenetheridge/DateTime-Format-Duration/master/docs/figure3.gif
.Sp
Figure 3 shows how leaps are calculated on timelines.
.SS "Normalising without a base"
.IX Subsection "Normalising without a base"
This module includes two ways to normalise without a base.
.IP "\(bu" 4
Standard Normalisation
.Sp
Using standard normalisation without a base, 45 days will stay as 45 days as there
is no way to accurately convert to months. However the following assumptions will
be made: There are 24 hours in a day and there are 60 seconds in a minute.
.IP "\(bu" 4
\&\s-1ISO\s0 Normalisation
.Sp
In ISO8601v2000, Section 5.5.3.2 says that \*(L"The values used must not exceed the
\&'carry\-over points' of 12 months, 30 days, 24 hours, 60 minutes and 60 seconds\*(R".
Thus if you set the normalise option of the constructor, or use set_normalising
to '\s-1ISO\s0', months will be normalised to 30 days.
.SS "Deltas vs Duration Objects"
.IX Subsection "Deltas vs Duration Objects"
This module can bypass duration objects and just work with delta hashes.
This used to be of greatest value with earlier versions of DateTime::Duration
when DateTime::Duration assumed a duration with one negative component was a
negative duration (that is, \-2 hours, 34 minutes was assumed to be \-2 hours,
\&\-34 minutes).
.PP
These extra methods have been left in here firstly for backwards-compatibility
but also as an added 'syntactic sugar'. Consider these two equivalent
expressions:
.PP
.Vb 7
\&    $one = $o\->format_duration(
\&        DateTime::Duration\->new(
\&            years => \-2,
\&            days  => 13,
\&            hours => \-1
\&        )
\&    );
\&
\&    $two = $o\->format_duration_from_deltas(
\&        years => \-2,
\&        days  => 13,
\&        hours => \-1
\&    );
.Ve
.PP
These both create the same string in \f(CW$one\fR and \f(CW$two\fR, but if you don't already
have a DateTime::Duration object, the later looks cleaner.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
datetime@perl.org mailing list
.PP
http://datetime.perl.org/
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs may be submitted through the \s-1RT\s0 bug tracker <https://rt.cpan.org/Public/Dist/Display.html?Name=DateTime-Format-Duration>
(or bug\-DateTime\-Format\-Duration@rt.cpan.org <mailto:bug-DateTime-Format-Duration@rt.cpan.org>).
.PP
There is also a mailing list available for users of this distribution, at
<http://lists.perl.org/list/datetime.html>.
.PP
I am also usually active on irc, as 'ether' at \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Rick Measham <rickm@cpan.org>
.SH "CONTRIBUTOR"
.IX Header "CONTRIBUTOR"
Karen Etheridge <ether@cpan.org>
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2003 by Rick Measham.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
