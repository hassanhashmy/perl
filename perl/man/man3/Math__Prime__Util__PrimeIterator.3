.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math::Prime::Util::PrimeIterator 3"
.TH Math::Prime::Util::PrimeIterator 3 "2017-12-02" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Prime::Util::PrimeIterator \- An object iterator for primes
.SH "VERSION"
.IX Header "VERSION"
Version 0.70
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Math::Prime::Util::PrimeIterator;
\&  my $it = Math::Prime::Util::PrimeIterator\->new();
\&
\&  # Simple use: return current value and move forward.
\&  my $sum = 0;  $sum += $it\->iterate() for 1..10000;
\&
\&  # Methods
\&  my $v = $it\->value();     # Return current value
\&  $it\->next();              # Move to next prime (returns self)
\&  $it\->prev();              # Move to prev prime (returns self)
\&  $v = $it\->iterate();      # Returns current value; moves to next prime
\&  $it\->rewind();            # Resets position to 2
\&  $it\->rewind($n);          # Resets position to next_prime($n\-1)
\&
\&  # Methods similar to Math::NumSeq, do not change iterator
\&  $it\->tell_i();            # Returns the index of the current position
\&  $it\->pred($n);            # Returns true if $n is prime
\&  $it\->ith($i);             # Returns the $ith prime
\&  $it\->value_to_i($n);      # Returns the index of the first prime >= $n
\&  $it\->value_to_i_estimate($n);  # Approx index of value $n
\&
\&  # Methods similar to Math::NumSeq, changes iterator
\&  $it\->seek_to_i($i);       # Resets position to the $ith prime
\&  $it\->seek_to_value($i);   # Resets position to next_prime($i\-1)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An iterator over the primes.  \*(L"new\*(R" returns an iterator object and takes
an optional starting position (the initial value will be the least prime
greater than or equal to the argument).  BigInt objects will be returned if
the value overflows a Perl unsigned integer value.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Creates an iterator object with initial value of 2.  If an argument is
given, the initial value will be the least prime greater than or equal
to the argument.
.SS "value"
.IX Subsection "value"
Returns the value at the current position.  Will always be a prime.  If
the value is greater than ~0, it will be a Math::BigInt object.
.SS "next"
.IX Subsection "next"
Moves the current position to the next prime.
Returns self so calls can be chained.
.SS "prev"
.IX Subsection "prev"
Moves the current position to the previous prime, unless the current
value is 2, in which case the value remains 2.
Returns self so calls can be chained.
.SS "iterate"
.IX Subsection "iterate"
Returns the value at the current position and also moves the position to
the next prime.
.SS "rewind"
.IX Subsection "rewind"
Resets the current position to either 2 or, if given an integer argument,
the least prime not less than the argument.
.SS "peek"
.IX Subsection "peek"
Returns the value at the next position without moving the iterator.
.SS "tell_i"
.IX Subsection "tell_i"
Returns the index of the current position, starting at 1 (corresponding to
the value 2).
The iterator is unchanged after this call.
.SS "pred"
.IX Subsection "pred"
Returns true if the argument is a prime, false otherwise.
The iterator is unchanged after this call.
.SS "ith"
.IX Subsection "ith"
Returns the i'th prime, where the first prime is 2.
The iterator is unchanged after this call.
.SS "value_to_i_estimate"
.IX Subsection "value_to_i_estimate"
Returns an estimate of the index corresponding to the argument.  That is,
given a value \f(CW\*(C`n\*(C'\fR, we expect a prime approximately equal to \f(CW\*(C`n\*(C'\fR to occur
at this index.
.PP
The estimate is performed using \*(L"prime_count_approx\*(R" in Math::Prime::Util,
which uses the estimates of Dusart 2010 (or better for small values).
.SS "value_to_i"
.IX Subsection "value_to_i"
If the argument is prime, returns the corresponding index, such that:
.PP
.Vb 1
\&  ith( value_to_i( $n ) ) == $n
.Ve
.PP
Returns \f(CW\*(C`undef\*(C'\fR if the argument is not prime.
.SS "value_to_i_floor"
.IX Subsection "value_to_i_floor"
.SS "value_to_i_ceil"
.IX Subsection "value_to_i_ceil"
Returns the index corresponding to the first prime less than or equal
to the argument, or greater than or equal to the argument, respectively.
.SS "seek_to_i"
.IX Subsection "seek_to_i"
Resets the position to the prime corresponding to the given index.
.SS "seek_to_value"
.IX Subsection "seek_to_value"
An alias for \*(L"rewind\*(R".
.SS "i_start =head2 description =head2 values_min =head2 values_max =head2 oeis_anum"
.IX Subsection "i_start =head2 description =head2 values_min =head2 values_max =head2 oeis_anum"
Methods to match Math::NumSeq::Primes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Prime::Util
.PP
\&\*(L"forprimes\*(R" in Math::Prime::Util
.PP
\&\*(L"prime_iterator\*(R" in Math::Prime::Util
.PP
\&\*(L"prime_iterator_object\*(R" in Math::Prime::Util
.PP
Math::Prime::Util::PrimeArray
.PP
Math::NumSeq::Primes
.PP
List::Gen
.SH "AUTHORS"
.IX Header "AUTHORS"
Dana Jacobsen <dana@acm.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2013 by Dana Jacobsen <dana@acm.org>
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
