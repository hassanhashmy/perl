.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Statement::Operation 3"
.TH SQL::Statement::Operation 3 "2017-04-06" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Statement::Operation \- base class for all operation terms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  # create an operation with an SQL::Statement object as owner, specifying
\&  # the operation name (for error purposes), the left and the right
\&  # operand
\&  my $term = SQL::Statement::Operation\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation is an abstract base class providing the interface
for all operation terms.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\&  SQL::Statement::Operation
\&  ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Instantiates new operation term.
.SS "value"
.IX Subsection "value"
Return the result of the operation of the term by calling operate
.SS "operate"
.IX Subsection "operate"
\&\fIAbstract\fR method which will do the operation of the term. Must be
overridden by derived classes.
.SS "op"
.IX Subsection "op"
Returns the name of the executed operation.
.SS "left"
.IX Subsection "left"
Returns the left operand (if any).
.SS "right"
.IX Subsection "right"
Returns the right operand (if any).
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
Destroys the term and undefines the weak reference to the owner as well
as the stored operation, the left and the right operand.
.SH "NAME"
SQL::Statement::Operation::Neg \- negate operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an <not> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and B<no> right operand
\&  my $term = SQL::Statement::Neg\->new( $owner, $op, $left, undef );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Neg
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Neg
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Return the logical negated value of the left operand.
.SH "NAME"
SQL::Statement::Operation::And \- and operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<and> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::And\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::And implements the logical \f(CW\*(C`and\*(C'\fR operation
between two terms.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::And
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Return the result of the logical \f(CW\*(C`and\*(C'\fR operation for the values of the
left and right operand.
.SH "NAME"
SQL::Statement::Operation::Or \- or operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<or> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Or\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Or implements the logical \f(CW\*(C`or\*(C'\fR operation
between two terms.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Or
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Return the result of the logical \f(CW\*(C`or\*(C'\fR operation for the values of the
left and right operand.
.SH "NAME"
SQL::Statement::Operation::Is \- is operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<is> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Is\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Is supports: \f(CW\*(C`IS NULL\*(C'\fR, \f(CW\*(C`IS TRUE\*(C'\fR and \f(CW\*(C`IS FALSE\*(C'\fR.
The right operand is always evaluated in boolean context in case of \f(CW\*(C`IS TRUE\*(C'\fR
and \f(CW\*(C`IS FALSE\*(C'\fR. \f(CW\*(C`IS NULL\*(C'\fR returns \fItrue\fR even if the left term is an empty
string (\f(CW\*(Aq\*(Aq\fR).
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Is
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Returns true when the left term is null, true or false \- based on the
requested right value.
.SH "NAME"
SQL::Statement::Operation::ANSI::Is \- is operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<is> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Is\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::ANSI::Is supports: \f(CW\*(C`IS NULL\*(C'\fR, \f(CW\*(C`IS TRUE\*(C'\fR and \f(CW\*(C`IS FALSE\*(C'\fR.
The right operand is always evaluated in boolean context in case of \f(CW\*(C`IS TRUE\*(C'\fR
and \f(CW\*(C`IS FALSE\*(C'\fR. \f(CW\*(C`IS NULL\*(C'\fR returns \fItrue\fR if the right term is not defined,
\&\fIfalse\fR otherwise.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Is
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Returns true when the left term is null, true or false \- based on the
requested right value.
.SH "NAME"
SQL::Statement::Operation::Contains \- in operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<in> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Contains\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Contains expects the right operand is an array
of SQL::Statement::Term instances. It checks whether the left operand
is in the list of the right operands or not like:
.PP
.Vb 1
\&  $left\->value($eval) ~~ map { $_\->value($eval) } @{$right}
.Ve
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Contains
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Returns true when the left term is equal to any of the right terms
.SH "NAME"
SQL::Statement::Operation::Between \- between operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<between> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Between\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Between expects the right operand is an array
of 2 SQL::Statement::Term instances. It checks whether the left operand
is between the right operands like:
.PP
.Vb 2
\&     ( $left\->value($eval) >= $right[0]\->value($eval) )
\&  && ( $left\->value($eval) <= $right[1]\->value($eval) )
.Ve
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Between
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Returns true when the left term is between both right terms
.SH "NAME"
SQL::Statement::Operation::Equality \- abstract base class for comparisons
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<equality> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Equality\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Equality implements compare operations between
two terms \- choosing either numerical comparison or string comparison,
depending whether both operands are numeric or not.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Equality
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Return the result of the comparison.
.SS "numcmp"
.IX Subsection "numcmp"
\&\fIAbstract\fR method which will do the numeric comparison of both terms. Must be
overridden by derived classes.
.SS "strcmp"
.IX Subsection "strcmp"
\&\fIAbstract\fR method which will do the string comparison of both terms. Must be
overridden by derived classes.
.SH "NAME"
SQL::Statement::Operation::Equal \- implements equal operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<equal> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Equal\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Equal implements compare operations between
two numbers and two strings.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::Equal
\&  ISA SQL::Statement::Operation::Equality
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "numcmp"
.IX Subsection "numcmp"
Return true when \f(CW\*(C`$left == $right\*(C'\fR
.SS "strcmp"
.IX Subsection "strcmp"
Return true when \f(CW\*(C`$left eq $right\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::NotEqual \- implements not equal operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<not equal> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::NotEqual\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::NotEqual implements negated compare operations
between two numbers and two strings.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::NotEqual
\&  ISA SQL::Statement::Operation::Equality
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "numcmp"
.IX Subsection "numcmp"
Return true when \f(CW\*(C`$left != $right\*(C'\fR
.SS "strcmp"
.IX Subsection "strcmp"
Return true when \f(CW\*(C`$left ne $right\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::Lower \- implements lower than operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<lower than> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Lower\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Lower implements lower than compare operations
between two numbers and two strings.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::Lower
\&  ISA SQL::Statement::Operation::Equality
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "numcmp"
.IX Subsection "numcmp"
Return true when \f(CW\*(C`$left < $right\*(C'\fR
.SS "strcmp"
.IX Subsection "strcmp"
Return true when \f(CW\*(C`$left lt $right\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::Greater \- implements greater than operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<greater than> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Greater\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Greater implements greater than compare operations
between two numbers and two strings.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::Greater
\&  ISA SQL::Statement::Operation::Equality
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "numcmp"
.IX Subsection "numcmp"
Return true when \f(CW$left \fR \f(CW$right\fR>
.SS "strcmp"
.IX Subsection "strcmp"
Return true when \f(CW\*(C`$left gt $right\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::LowerEqual \- implements lower equal operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<lower equal> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::LowerEqual\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::LowerEqual implements lower equal compare operations
between two numbers and two strings.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::LowerEqual
\&  ISA SQL::Statement::Operation::Equality
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "numcmp"
.IX Subsection "numcmp"
Return true when \f(CW\*(C`$left <= $right\*(C'\fR
.SS "strcmp"
.IX Subsection "strcmp"
Return true when \f(CW\*(C`$left le $right\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::GreaterEqual \- implements greater equal operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<greater equal> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::GreaterEqual\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::GreaterEqual implements greater equal compare operations
between two numbers and two strings.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::GreaterEqual
\&  ISA SQL::Statement::Operation::Equality
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "numcmp"
.IX Subsection "numcmp"
Return true when \f(CW$left \fR= \f(CW$right\fR>
.SS "strcmp"
.IX Subsection "strcmp"
Return true when \f(CW\*(C`$left ge $right\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::Regexp \- abstract base class for comparisons based on regular expressions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<regexp> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Regexp\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Regexp implements the comparisons for the \f(CW\*(C`LIKE\*(C'\fR
operation family.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Operation::Regexp
\&  ISA SQL::Statement::Operation
\&    ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "operate"
.IX Subsection "operate"
Return the result of the comparison.
.SS "right"
.IX Subsection "right"
Returns the regular expression based on the right term. The right term
is expected to be constant \- so \f(CW\*(C`a LIKE b\*(C'\fR in not supported.
.SS "regexp"
.IX Subsection "regexp"
\&\fIAbstract\fR method which must return a regular expression (\f(CW\*(C`qr//\*(C'\fR) from
the given string.  Must be overridden by derived classes.
.SH "NAME"
SQL::Statement::Operation::Like \- implements the like operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<like> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Like\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Like is used to the comparisons for the \f(CW\*(C`LIKE\*(C'\fR
operation.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::Like
\&  ISA SQL::Statement::Operation::Regexp
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "regexp"
.IX Subsection "regexp"
Returns \f(CW\*(C`qr/^$right$/s\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::Clike \- implements the clike operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<clike> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::Clike\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::Clike is used to the comparisons for the \f(CW\*(C`CLIKE\*(C'\fR
operation.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::Clike
\&  ISA SQL::Statement::Operation::Regexp
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "regexp"
.IX Subsection "regexp"
Returns \f(CW\*(C`qr/^$right$/si\*(C'\fR
.SH "NAME"
SQL::Statement::Operation::RLike \- implements the rlike operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an C<rlike> operation with an SQL::Statement object as owner,
\&  # specifying the operation name, the left and the right operand
\&  my $term = SQL::Statement::RLike\->new( $owner, $op, $left, $right );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Statement::Operation::RLike is used to the comparisons for the \f(CW\*(C`RLIKE\*(C'\fR
operation.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\&  SQL::Statement::Operation::RLike
\&  ISA SQL::Statement::Operation::Regexp
\&    ISA SQL::Statement::Operation
\&      ISA SQL::Statement::Term
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "regexp"
.IX Subsection "regexp"
Returns \f(CW\*(C`qr/$right$/s\*(C'\fR
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2009,2017 by Jens Rehsack: rehsackATcpan.org
.PP
All rights reserved.
.PP
You may distribute this module under the terms of either the \s-1GNU\s0
General Public License or the Artistic License, as specified in
the Perl \s-1README\s0 file.
