.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ActiveState::Run 3"
.TH ActiveState::Run 3 "2017-06-23" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ActiveState::Run \- Collection of small utility functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use ActiveState::Run qw(run);
\& run("ls \-l");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a collection of small utility functions for
running external programs.
.PP
The following functions are provided:
.IP "decode_status( )" 4
.IX Item "decode_status( )"
.PD 0
.ie n .IP "decode_status( $rc )" 4
.el .IP "decode_status( \f(CW$rc\fR )" 4
.IX Item "decode_status( $rc )"
.PD
Will decode the given return code (defaults to $?) and return the 
exit value, the signal it was killed with, and if it dumped core.
.Sp
In scalar context, it will return a string explaining what happened, or 
an empty string if no error occured.
.Sp
.Vb 3
\&  my $foo = \`ls\`;
\&  my $err = decode_status;
\&  die "ls failed: $err" if $err;
.Ve
.Sp
In array context, it will return a list of key/value pairs containing:
.RS 4
.IP "\s-1WIFEXITED\s0" 4
.IX Item "WIFEXITED"
True when the status code indicates normal termination.
.IP "\s-1WEXITSTATUS\s0" 4
.IX Item "WEXITSTATUS"
If \s-1WIFEXITED,\s0 this will contain the low-order 8 bits of the status
value the child passed to exit or returned from main.
.IP "\s-1WIFSIGNALED\s0" 4
.IX Item "WIFSIGNALED"
Non-zero if process was terminated by a signal.
.IP "\s-1WTERMSIG\s0" 4
.IX Item "WTERMSIG"
If \s-1WIFSIGNALED,\s0 the terminating signal.
.IP "\s-1WIFSTOPPED\s0" 4
.IX Item "WIFSTOPPED"
Non-zero if the process was stopped.
.IP "\s-1WSTOPSIG\s0" 4
.IX Item "WSTOPSIG"
If \s-1WIFSTOPPED,\s0 the signal that stopped the process.
.IP "\s-1WCOREDUMP\s0" 4
.IX Item "WCOREDUMP"
Nonzero if the process dumped core.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 3
\&  my $foo = \`ls\`;
\&  my %err = decode_status;
\&  die "ls dumped core" if $err{WCOREDUMP};
.Ve
.RE
.ie n .IP "run( $cmd, @args )" 4
.el .IP "run( \f(CW$cmd\fR, \f(CW@args\fR )" 4
.IX Item "run( $cmd, @args )"
Works like the builtin \fBsystem()\fR but will by default print commands to
stdout before it execute them and raise an exception (die) if the
command fails (returns non-zero status).  Like for the command
specifications for \fBmake\fR\|(1), you can prefix the command with \*(L"@\*(R" to
suppress the echo and with \*(L"\-\*(R" to suppress the status check.
.Sp
The environment variables \s-1AS_RUN_SILENT\s0 and \s-1AS_RUN_PREFIX\s0 influence
printing as well, see \*(L"\s-1ENVIRONMENT\*(R"\s0.
.ie n .IP "run_ex( %opt )" 4
.el .IP "run_ex( \f(CW%opt\fR )" 4
.IX Item "run_ex( %opt )"
The extended version of the run function with many additional ways to
control the how the command runs, but otherwise it acts as \fBrun()\fR.
.Sp
The following options are recognized:
.RS 4
.ie n .IP "cmd => $cmd" 4
.el .IP "cmd => \f(CW$cmd\fR" 4
.IX Item "cmd => $cmd"
.PD 0
.ie n .IP "cmd => [$cmd, @args]" 4
.el .IP "cmd => [$cmd, \f(CW@args\fR]" 4
.IX Item "cmd => [$cmd, @args]"
.PD
Specify the command line to run.  It does not support the '@' and '\-'
prefixes that the \fBrun()\fR command allow.  This option is not optional :)
.ie n .IP "exe => $path" 4
.el .IP "exe => \f(CW$path\fR" 4
.IX Item "exe => $path"
Only use this if you want to override what executable actually runs.
Can be used to lie about what program actually runs, as this allow
argv[0] to be different than the actual command.
.ie n .IP "cwd => $path" 4
.el .IP "cwd => \f(CW$path\fR" 4
.IX Item "cwd => $path"
Make this the current directory of the process.  By default, the
process shares the parent's current directory.
.IP "env => \e%hash" 4
.IX Item "env => %hash"
Override the environment for the process.
.IP "env_hide => \e@keys" 4
.IX Item "env_hide => @keys"
List of environment variables that will not be passed to the kid.  You
might pass this as \f(CW\*(C`[keys %ENV]\*(C'\fR if you want the process to start
out with an environment that only consist of what you passed in with the
\&\f(CW\*(C`env\*(C'\fR option.
.ie n .IP "stdin => $filehandle" 4
.el .IP "stdin => \f(CW$filehandle\fR" 4
.IX Item "stdin => $filehandle"
Make the new process run with stdin from the given filehandle.  If not
given the process will be started with \fI/dev/null\fR as its input.  If
you want the process to inherit the input of the parent you need to
pass \f(CW*STDIN\fR explictly.
.ie n .IP "output => $path" 4
.el .IP "output => \f(CW$path\fR" 4
.IX Item "output => $path"
Redirect the combined \s-1STDOUT\s0 and \s-1STDERR\s0 to the given file.  The
command will croak if the file can't be opened.  If not specified,
then the \s-1STDOUT\s0 and \s-1STDERR\s0 of the process is simply inherited from the
parent.
.ie n .IP "silent => $bool" 4
.el .IP "silent => \f(CW$bool\fR" 4
.IX Item "silent => $bool"
If \s-1TRUE\s0 don't echo commands as they are executed.
.ie n .IP "ignore_err => $bool" 4
.el .IP "ignore_err => \f(CW$bool\fR" 4
.IX Item "ignore_err => $bool"
If \s-1TRUE\s0 don't croak if the command exits with a non-zero status.
.ie n .IP "nice => $bool" 4
.el .IP "nice => \f(CW$bool\fR" 4
.IX Item "nice => $bool"
Be nice!
.ie n .IP "tee => $bool" 4
.el .IP "tee => \f(CW$bool\fR" 4
.IX Item "tee => $bool"
If \s-1TRUE\s0 send the output captured in the \f(CW\*(C`output\*(C'\fR file to the current \s-1STDOUT\s0
as well.  No effect unless \f(CW\*(C`output\*(C'\fR is specified.
.ie n .IP "new_group => $bool" 4
.el .IP "new_group => \f(CW$bool\fR" 4
.IX Item "new_group => $bool"
If \s-1TRUE\s0 start a new process group for the process.
.ie n .IP "limit_time => $seconds" 4
.el .IP "limit_time => \f(CW$seconds\fR" 4
.IX Item "limit_time => $seconds"
Kill the process (or the process group if \f(CW\*(C`new_group\*(C'\fR was specified)
if it runs for longer than the specified number of seconds.
.ie n .IP "limit_output => $megabytes" 4
.el .IP "limit_output => \f(CW$megabytes\fR" 4
.IX Item "limit_output => $megabytes"
Kill the process (or the process group if \f(CW\*(C`new_group\*(C'\fR was specified)
if it output file grows bigger than the specified number of mega
bytes.  No effect unless \f(CW\*(C`output\*(C'\fR was specified.
.ie n .IP "limit_cpu => $seconds" 4
.el .IP "limit_cpu => \f(CW$seconds\fR" 4
.IX Item "limit_cpu => $seconds"
.PD 0
.ie n .IP "limit_XXX => $megabytes" 4
.el .IP "limit_XXX => \f(CW$megabytes\fR" 4
.IX Item "limit_XXX => $megabytes"
.PD
Other limits might also be passed which will set how much resources the process
is allowed to use.  The unit for all size limits are megabytes.  See
\&\f(CW\*(C`BSD::Resource\*(C'\fR for allowed values.  Also consult the \f(CW\*(C`ulimit\*(C'\fR command in you
shell.
.RE
.RS 4
.RE
.ie n .IP "shell_quote( @args )" 4
.el .IP "shell_quote( \f(CW@args\fR )" 4
.IX Item "shell_quote( @args )"
Will quote the arguments provided so that they can be passed to the
command shell without interpretation by the shell.  This is useful
with \fBrun()\fR when you can't provide separate \f(CW@args\fR, e.g.:
.Sp
.Vb 1
\&   run(shell_quote("rm", "\-f", @files) . " >dev/null");
.Ve
.Sp
In list context it returns the same number of values as arguments
passed in.  Only those arg values that need quoting will be quoted.
.Sp
In scalar context it will return a single string with all the quoted
\&\f(CW@args\fR separated by space.
.Sp
In void context it will attempt inline modification of the \f(CW@args\fR
passed.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
If the \s-1AS_RUN_SILENT\s0 environment variable is \s-1TRUE,\s0 then printing of
the command about to run for \fBrun()\fR is suppressed.
.PP
If the \s-1AS_RUN_PREFIX\s0 environment variable is set, then the printed
command is prefixed with the given string.  If \s-1AS_RUN_SILENT\s0 is \s-1TRUE,\s0
then this value is ignored.
.SH "BUGS"
.IX Header "BUGS"
none.
