.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math::Prime::Util::PrimalityProving 3"
.TH Math::Prime::Util::PrimalityProving 3 "2017-12-02" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Prime::Util::PrimalityProving \- Primality proofs and certificates
.SH "VERSION"
.IX Header "VERSION"
Version 0.70
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Routines to support primality proofs and certificate verification.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "primality_proof_lucas"
.IX Subsection "primality_proof_lucas"
Given a positive number \f(CW\*(C`n\*(C'\fR as input, performs a full factorization of \f(CW\*(C`n\-1\*(C'\fR,
then attempts a Lucas test on the result.  A Pratt-style certificate is
returned.  Note that if the input is composite, this will take a \fBvery\fR long
time to return.
.SS "primality_proof_bls75"
.IX Subsection "primality_proof_bls75"
Given a positive number \f(CW\*(C`n\*(C'\fR as input, performs a partial factorization of
\&\f(CW\*(C`n\-1\*(C'\fR, then attempts a proof using theorem 5 of Brillhart, Lehmer, and
Selfridge's 1975 paper.  This can take a long time to return if given a
composite, though it should not be anywhere near as long as the Lucas test.
.SS "convert_array_cert_to_string"
.IX Subsection "convert_array_cert_to_string"
Takes as input a Perl structure certificate, used by Math::Prime::Util
from version 0.26 through 0.29, and converts it to a multi-line text
certificate starting with \*(L"[\s-1MPU\s0 \- Primality Certificate]\*(R".  This is the
new format produced and processed by Math::Prime::Util, Math::Prime::Util::GMP,
and associated tools.
.SS "verify_cert"
.IX Subsection "verify_cert"
Takes a \s-1MPU\s0 primality certificate and verifies that it does prove the
primality of the number it represents (the N after the \*(L"Proof for:\*(R" line).
For backwards compatibility, if given an old-style Perl structure, it will
be converted then verified.
.PP
The return value will be \f(CW0\fR (failed to verify) or \f(CW1\fR (verified).
A result of \f(CW0\fR does \fInot\fR indicate the number is composite; it only
indicates the proof given is not sufficient.
.PP
If the certificate is malformed, the routine will carp a warning in addition
to returning 0.  If the \f(CW\*(C`verbose\*(C'\fR option is set (see \*(L"prime_set_config\*(R")
then if the validation fails, the reason for the failure is printed in
addition to returning 0.  If the \f(CW\*(C`verbose\*(C'\fR option is set to 2 or higher, then
a message indicating success and the certificate type is also printed.
.PP
A later release may add support for
Primo <http://www.ellipsa.eu/public/primo/primo.html>
certificates, as all the method verifications are coded.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Prime::Util
.SH "AUTHORS"
.IX Header "AUTHORS"
Dana Jacobsen <dana@acm.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2012\-2013 by Dana Jacobsen <dana@acm.org>
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
