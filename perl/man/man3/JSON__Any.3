.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "JSON::Any 3"
.TH JSON::Any 3 "2015-06-10" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::Any \- (DEPRECATED) Wrapper Class for the various JSON classes
.SH "VERSION"
.IX Header "VERSION"
version 1.39
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use JSON::Any;
\&    my $j = JSON::Any\->new;
\&    my $json = $j\->objToJson({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&    my $obj = $j\->jsonToObj($json);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module tries to provide a coherent \s-1API\s0 to bring together the various \s-1JSON\s0
modules currently on \s-1CPAN.\s0 This module will allow you to code to any \s-1JSON API\s0
and have it work regardless of which \s-1JSON\s0 module is actually installed.
.PP
.Vb 1
\&    use JSON::Any;
\&
\&    my $j = JSON::Any\->new;
\&
\&    $json = $j\->objToJson({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&    $obj = $j\->jsonToObj($json);
.Ve
.PP
or
.PP
.Vb 2
\&    $json = $j\->encode({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&    $obj = $j\->decode($json);
.Ve
.PP
or
.PP
.Vb 2
\&    $json = $j\->Dump({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&    $obj = $j\->Load($json);
.Ve
.PP
or
.PP
.Vb 2
\&    $json = $j\->to_json({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&    $obj = $j\->from_json($json);
.Ve
.PP
or without creating an object:
.PP
.Vb 2
\&    $json = JSON::Any\->objToJson({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&    $obj = JSON::Any\->jsonToObj($json);
.Ve
.PP
On load, JSON::Any will find a valid \s-1JSON\s0 module in your \f(CW@INC\fR by looking
for them in this order:
.PP
.Vb 5
\&    Cpanel::JSON::XS
\&    JSON::XS
\&    JSON::PP
\&    JSON
\&    JSON::DWIW
.Ve
.PP
And loading the first one it finds.
.PP
You may change the order by specifying it on the \f(CW\*(C`use JSON::Any\*(C'\fR line:
.PP
.Vb 1
\&    use JSON::Any qw(DWIW XS CPANEL JSON PP);
.Ve
.PP
Specifying an order that is missing modules will prevent those module from
being used:
.PP
.Vb 1
\&    use JSON::Any qw(CPANEL PP); # same as JSON::MaybeXS
.Ve
.PP
This will check in that order, and will never attempt to load \s-1JSON::XS\s0,
\&\*(L"\s-1JSON\*(R"\s0 in \s-1JSON\s0.pm, or \s-1JSON::DWIW\s0. This can also be set via the \f(CW$ENV{JSON_ANY_ORDER}\fR
environment variable.
.PP
JSON::Syck has been deprecated by its author, but in the attempt to still
stay relevant as a \*(L"Compatibility Layer\*(R" JSON::Any still supports it. This support
however has been made optional starting with JSON::Any 1.19. In deference to a
bug request starting with \s-1JSON\s0.pm 1.20, JSON::Syck and other deprecated modules
will still be installed, but only as a last resort and will now include a
warning.
.PP
.Vb 1
\&    use JSON::Any qw(Syck XS JSON);
.Ve
.PP
or
.PP
.Vb 1
\&    $ENV{JSON_ANY_ORDER} = \*(AqSyck XS JSON\*(Aq;
.Ve
.PP
At install time, JSON::Any will attempt to install \s-1JSON::PP\s0 as a reasonable
fallback if you do not appear have \fBany\fR backends installed on your system.
.PP
\&\s-1WARNING:\s0 If you call JSON::Any with an empty list
.PP
.Vb 1
\&    use JSON::Any ();
.Ve
.PP
It will skip the \s-1JSON\s0 package detection routines and will die loudly that it
couldn't find a package.
.SH "DEPRECATION NOTICE"
.IX Header "DEPRECATION NOTICE"
The original need for JSON::Any has been solved (quite some time ago
actually). If you're producing new code it is recommended to use JSON::MaybeXS which
will optionally use Cpanel::JSON::XS for speed purposes.
.PP
JSON::Any will continue to be maintained for compatibility with existing code,
but for new code you should strongly consider using JSON::MaybeXS instead.
.SH "WARNING"
.IX Header "WARNING"
\&\s-1JSON::XS\s0 3.0 or higher has a conflict with any version of \s-1JSON\s0.pm less than 2.90
when you use \s-1JSON\s0.pm's \f(CW\*(C`\-support_by_pp\*(C'\fR option, which JSON::Any enables by
default.
.PP
This situation should only come up with JSON::Any if you have \s-1JSON\s0.pm 2.61 or
lower \fBand\fR \s-1JSON::XS\s0 3.0 or higher installed, and you use \s-1JSON\s0.pm
via \f(CW\*(C`use JSON::Any qw(JSON);\*(C'\fR or the \f(CW\*(C`JSON_ANY_ORDER\*(C'\fR environment variable.
.PP
If you run into an issue where you're getting recursive inheritance errors in a
Types::Serialiser package, please try upgrading \s-1JSON\s0.pm to 2.90 or higher.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
Will take any of the parameters for the underlying system and pass them
through. However these values don't map between \s-1JSON\s0 modules, so, from a
portability standpoint this is really only helpful for those parameters that
happen to have the same name.
.PP
The one parameter that is universally supported (to the extent that is
supported by the underlying \s-1JSON\s0 modules) is \f(CW\*(C`utf8\*(C'\fR. When this parameter is
enabled all resulting \s-1JSON\s0 will be marked as unicode, and all unicode strings
in the input data structure will be preserved as such.
.PP
Also note that the \f(CW\*(C`allow_blessed\*(C'\fR parameter is recognised by all the modules
that throw exceptions when a blessed reference is given them meaning that
setting it to true works for all modules. Of course, that means that you
cannot set it to false intentionally in order to always get such exceptions.
.PP
The actual output will vary, for example \s-1JSON\s0 will encode and decode
unicode chars (the resulting \s-1JSON\s0 is not unicode) whereas \s-1JSON::XS\s0 will emit
unicode \s-1JSON.\s0
.ie n .SS """handlerType"""
.el .SS "\f(CWhandlerType\fP"
.IX Subsection "handlerType"
Takes no arguments, returns a string indicating which \s-1JSON\s0 Module is in use.
.ie n .SS """handler"""
.el .SS "\f(CWhandler\fP"
.IX Subsection "handler"
Takes no arguments, if called on an object returns the internal JSON::*
object in use.  Otherwise returns the JSON::* package we are using for
class methods.
.ie n .SS """true"""
.el .SS "\f(CWtrue\fP"
.IX Subsection "true"
Takes no arguments, returns the special value that the internal \s-1JSON\s0
object uses to map to a \s-1JSON\s0 \f(CW\*(C`true\*(C'\fR boolean.
.ie n .SS """false"""
.el .SS "\f(CWfalse\fP"
.IX Subsection "false"
Takes no arguments, returns the special value that the internal \s-1JSON\s0
object uses to map to a \s-1JSON\s0 \f(CW\*(C`false\*(C'\fR boolean.
.ie n .SS """objToJson"""
.el .SS "\f(CWobjToJson\fP"
.IX Subsection "objToJson"
Takes a single argument, a hashref to be converted into \s-1JSON.\s0
It returns the \s-1JSON\s0 text in a scalar.
.ie n .SS """to_json"""
.el .SS "\f(CWto_json\fP"
.IX Subsection "to_json"
.ie n .SS """Dump"""
.el .SS "\f(CWDump\fP"
.IX Subsection "Dump"
.ie n .SS """encode"""
.el .SS "\f(CWencode\fP"
.IX Subsection "encode"
Aliases for \f(CW\*(C`objToJson\*(C'\fR, can be used interchangeably, regardless of the
underlying \s-1JSON\s0 module.
.ie n .SS """jsonToObj"""
.el .SS "\f(CWjsonToObj\fP"
.IX Subsection "jsonToObj"
Takes a single argument, a string of \s-1JSON\s0 text to be converted
back into a hashref.
.ie n .SS """from_json"""
.el .SS "\f(CWfrom_json\fP"
.IX Subsection "from_json"
.ie n .SS """Load"""
.el .SS "\f(CWLoad\fP"
.IX Subsection "Load"
.ie n .SS """decode"""
.el .SS "\f(CWdecode\fP"
.IX Subsection "decode"
Aliases for \f(CW\*(C`jsonToObj\*(C'\fR, can be used interchangeably, regardless of the
underlying \s-1JSON\s0 module.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This module came about after discussions on irc.perl.org about the fact
that there were now six separate \s-1JSON\s0 perl modules with different interfaces.
.PP
In the spirit of Class::Any, JSON::Any was created with the considerable
help of Matt 'mst' Trout.
.PP
Simon Wistow graciously supplied a patch for backwards compatibility with \s-1JSON::XS\s0
versions previous to 2.01
.PP
San Dimas High School Football Rules!
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Chris Thompson <cthom@cpan.org>
.IP "\(bu" 4
Chris Prather <chris@prather.org>
.IP "\(bu" 4
Robin Berjon <robin@berjon.com>
.IP "\(bu" 4
Marc Mims <marc@questright.com>
.IP "\(bu" 4
Tomas Doran <bobtfish@bobtfish.net>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.IP "\(bu" 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP "\(bu" 4
Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
.IP "\(bu" 4
Justin Hunter <justin.d.hunter@gmail.com>
.IP "\(bu" 4
Todd Rinaldo <toddr@cpan.org>
.IP "\(bu" 4
Matthew Horsfall <wolfsage@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2007 by Chris Thompson.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
