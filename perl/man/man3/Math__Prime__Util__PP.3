.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math::Prime::Util::PP 3"
.TH Math::Prime::Util::PP 3 "2017-12-02" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Prime::Util::PP \- Pure Perl version of Math::Prime::Util
.SH "VERSION"
.IX Header "VERSION"
Version 0.70
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The functionality is basically identical to Math::Prime::Util, as this
module is just the Pure Perl implementation.  This documentation will only
note differences.
.PP
.Vb 3
\&  # Normally you would just import the functions you are using.
\&  # Nothing is exported by default.
\&  use Math::Prime::Util \*(Aq:all\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pure Perl implementations of prime number utilities that are normally
handled with \s-1XS\s0 or \s-1GMP.\s0  Having the Perl implementations (1) provides examples,
(2) allows the functions to run even if \s-1XS\s0 isn't available, and (3) gives
big number support if Math::Prime::Util::GMP isn't available.  This is a
subset of Math::Prime::Util's functionality.
.PP
All routines should work with native integers or multi-precision numbers.  To
enable big numbers, use bigint or bignum:
.PP
.Vb 3
\&    use bigint;
\&    say prime_count_approx(1000000000000000000000000)\*(Aq
\&    # says 18435599767347543283712
.Ve
.PP
This is still experimental, and some functions will be very slow.  The
Math::Prime::Util::GMP module has much faster versions of many of these
functions.  Alternately, Math::Pari has a lot of these types of functions.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "euler_phi"
.IX Subsection "euler_phi"
Takes a \fIsingle\fR integer input and returns the Euler totient.
.SS "euler_phi_range"
.IX Subsection "euler_phi_range"
Takes two values defining a range \f(CW\*(C`low\*(C'\fR to \f(CW\*(C`high\*(C'\fR and returns an array
with the totient of each value in the range, inclusive.
.SS "moebius"
.IX Subsection "moebius"
Takes a \fIsingle\fR integer input and returns the Moebius function.
.SS "moebius_range"
.IX Subsection "moebius_range"
Takes two values defining a range \f(CW\*(C`low\*(C'\fR to \f(CW\*(C`high\*(C'\fR and returns an array
with the Moebius function of each value in the range, inclusive.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
The \s-1SQUFOF\s0 and Fermat factoring algorithms are not implemented yet.
.PP
Some of the prime methods use more memory than they should, as the segmented
sieve is not properly used in \f(CW\*(C`primes\*(C'\fR and \f(CW\*(C`prime_count\*(C'\fR.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
Performance compared to the \s-1XS/C\s0 code is quite poor for many operations.  Some
operations that are relatively close for small and medium-size values:
.PP
.Vb 5
\&  next_prime / prev_prime
\&  is_prime / is_prob_prime
\&  is_strong_pseudoprime
\&  ExponentialIntegral / LogarithmicIntegral / RiemannR
\&  primearray
.Ve
.PP
Operations that are slower include:
.PP
.Vb 6
\&  primes
\&  random_prime / random_ndigit_prime
\&  factor / factor_exp / divisors
\&  nth_prime
\&  prime_count
\&  is_aks_prime
.Ve
.PP
Performance improvement in this code is still possible.  The prime sieve is
over 2x faster than anything I was able to find online, but it is still has
room for improvement.
.PP
Math::Prime::Util::GMP offers \f(CW\*(C`C+XS+GMP\*(C'\fR support for most of the important
functions, and will be vastly faster for most operations.  If you install that
module, Math::Prime::Util will load it automatically, meaning you should
not have to think about what code is actually being used (C, \s-1GMP,\s0 or Perl).
.PP
Memory use will generally be higher for the \s-1PP\s0 code, and in some cases \fBmuch\fR
higher.  Some of this may be addressed in a later release.
.PP
For small values (e.g. primes and prime counts under 10M) most of this will
not matter.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Prime::Util
.PP
Math::Prime::Util::GMP
.SH "AUTHORS"
.IX Header "AUTHORS"
Dana Jacobsen <dana@acm.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2012\-2016 by Dana Jacobsen <dana@acm.org>
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
